//#region src/array/chunk.d.ts
/**
 * Split array into chunks
 *
 * å°†æ•°ç»„æ‹†åˆ†æˆå—
 *
 * @category Array
 *
 * @param input - the array
 * @param size - the chunk size. å—çš„å¤§å°
 *
 * @example
 * ```ts
 * chunk([1, 2, 3, 4, 5], 2) // => [[1, 2], [3, 4], [5]]
 * ```
 */
declare function chunk<T>(input: T[], size?: number): T[][];
//#endregion
//#region src/array/difference.d.ts
/**
 * Computes the difference between two arrays.
 *
 * This function takes two arrays and returns a new array containing the elements
 * that are present in the first array but not in the second array. It effectively
 * filters out any elements from the first array that also appear in the second array.
 *
 * è®¡ç®—ä¸¤ä¸ªæ•°ç»„ä¹‹é—´çš„å·®å¼‚ã€‚
 *
 * æ­¤å‡½æ•°æ¥æ”¶ä¸¤ä¸ªæ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼Œå…¶ä¸­åŒ…å«å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„ä¸­ä½†ä¸åœ¨ç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ã€‚
 * å®ƒæœ‰æ•ˆåœ°è¿‡æ»¤æ‰ç¬¬ä¸€ä¸ªæ•°ç»„ä¸­åŒæ—¶å‡ºç°åœ¨ç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„ä»»ä½•å…ƒç´ ã€‚
 *
 * @category Array
 *
 * @param firstArr - the first array. ç¬¬ä¸€ä¸ªæ•°ç»„
 * @param secondArr - the second array. ç¬¬äºŒä¸ªæ•°ç»„
 * @returns - a new array containing the elements that are present in the first array but not in the second array. -- åŒ…å«å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„ä¸­ä½†ä¸åœ¨ç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ çš„æ–°æ•°ç»„
 *
 * @example
 * ```ts
 * difference([1, 2, 3, 4, 5], [2, 4])
 * // => [1, 3, 5]
 * ```
 */
declare function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[];
/**
 * Computes the difference between two arrays after mapping their elements through a provided function.
 *
 * This function takes two arrays and a mapper function. It returns a new array containing the elements
 * that are present in the first array but not in the second array, based on the identity calculated
 * by the mapper function.
 *
 * Essentially, it filters out any elements from the first array that, when
 * mapped, match an element in the mapped version of the second array.
 *
 * è®¡ç®—ä¸¤ä¸ªæ•°ç»„åœ¨é€šè¿‡æä¾›çš„å‡½æ•°æ˜ å°„å…¶å…ƒç´ åçš„å·®å¼‚ã€‚
 *
 * æ­¤å‡½æ•°æ¥æ”¶ä¸¤ä¸ªæ•°ç»„å’Œä¸€ä¸ªæ˜ å°„å‡½æ•°ã€‚å®ƒè¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼ŒåŒ…å«é‚£äº›å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„ä¸­ä½†ä¸åœ¨ç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ï¼Œ
 * åŸºäºæ˜ å°„å‡½æ•°è®¡ç®—å‡ºçš„æ ‡è¯†ã€‚
 *
 * æœ¬è´¨ä¸Šï¼Œå®ƒä¼šè¿‡æ»¤æ‰ç¬¬ä¸€ä¸ªæ•°ç»„ä¸­é‚£äº›åœ¨æ˜ å°„åä¸ç¬¬äºŒä¸ªæ•°ç»„æ˜ å°„ç‰ˆæœ¬ä¸­å…ƒç´ åŒ¹é…çš„å…ƒç´ ã€‚
 *
 * @category Array
 * @example
 * ```ts
 * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
 * const array2 = [{ id: 2 }, { id: 4 }]
 * const mapper = item => item.id
 * const result = differenceBy(array1, array2, mapper)
 * // -> [{ id: 1 }, { id: 3 }]
 * ```
 * @example
 * ```ts
 * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
 * const array2 = [2, 4]
 * const mapper = item => (typeof item === 'object' ? item.id : item)
 * const result = differenceBy(array1, array2, mapper)
 * // -> [{ id: 1 }, { id: 3 }]
 * ```
 */
declare function differenceBy<T, U>(firstArr: readonly T[], secondArr: readonly U[], mapper: (value: T | U) => unknown): T[];
//#endregion
//#region src/array/filter-async.d.ts
/**
 * Filters an array asynchronously using an async predicate function.
 *
 * Returns a promise that resolves to a new array containing only the elements
 * for which the predicate function returns a truthy value.
 *
 * ä½¿ç”¨å¼‚æ­¥è°“è¯å‡½æ•°å¯¹æ•°ç»„è¿›è¡Œå¼‚æ­¥è¿‡æ»¤ã€‚
 *
 * è¿”å›ä¸€ä¸ªPromiseï¼Œè¯¥Promiseè§£æä¸ºä¸€ä¸ªæ–°æ•°ç»„ï¼Œä»…åŒ…å«è°“è¯å‡½æ•°è¿”å›çœŸå€¼çš„å…ƒç´ ã€‚
 *
 * @category Array
 * @example
 * ```ts
 * const users = [{ id: 1, active: true }, { id: 2, active: false }, { id: 3, active: true }];
 * const activeUsers = await filterAsync(users, async (user) => {
 *   return await checkUserStatus(user.id);
 * });
 * // Returns: [{ id: 1, active: true }, { id: 3, active: true }]
 * ```
 */
declare function filterAsync<T>(array: readonly T[], predicate: (item: T, index: number, array: readonly T[]) => Promise<boolean>, concurrency?: number): Promise<T[]>;
//#endregion
//#region src/array/intersection.d.ts
/**
 * Computes the intersection between two arrays.
 *
 * This function takes two arrays and returns a new array containing elements that exist in both the first and second arrays.
 * It effectively filters out any elements that do not appear in both arrays.
 *
 * è®¡ç®—ä¸¤ä¸ªæ•°ç»„ä¹‹é—´çš„å·®å¼‚ã€‚
 *
 * æ­¤å‡½æ•°æ¥æ”¶ä¸¤ä¸ªæ•°ç»„ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼Œå…¶ä¸­åŒ…å«åŒæ—¶å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„å’Œç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ã€‚
 * å®ƒæœ‰æ•ˆåœ°è¿‡æ»¤æ‰ä¸åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­åŒæ—¶å‡ºç°çš„ä»»ä½•å…ƒç´ ã€‚
 *
 * @category Array
 *
 * @param firstArr - the first array. ç¬¬ä¸€ä¸ªæ•°ç»„
 * @param secondArr - the second array. ç¬¬äºŒä¸ªæ•°ç»„
 * @returns - a new array containing elements that exist in both the first and second arrays. -- åŒ…å«åŒæ—¶å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„å’Œç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ çš„æ–°æ•°ç»„
 *
 * @example
 * ```ts
 * intersection([1, 2, 3, 4, 5], [2, 4, 6])
 * // => [2, 4]
 * ```
 */
declare function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[];
/**
 * Computes the intersection between two arrays after mapping their elements through a provided function.
 *
 * This function takes two arrays and a mapper function. It returns a new array containing elements that exist in both the first and second arrays.
 * It effectively filters out any elements that do not appear in both arrays.
 *
 * Essentially, it only retains those elements from the first array that, after mapping, match elements in the mapped version of the second array.
 *
 * è®¡ç®—ä¸¤ä¸ªæ•°ç»„åœ¨é€šè¿‡æä¾›çš„å‡½æ•°æ˜ å°„å…¶å…ƒç´ åçš„äº¤é›†ã€‚
 *
 * æ­¤å‡½æ•°æ¥æ”¶ä¸¤ä¸ªæ•°ç»„å’Œä¸€ä¸ªæ˜ å°„å‡½æ•°ã€‚å®ƒè¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼Œå…¶ä¸­åŒ…å«åŒæ—¶å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„å’Œç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ã€‚
 * å®ƒæœ‰æ•ˆåœ°è¿‡æ»¤æ‰ä¸åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­åŒæ—¶å‡ºç°çš„ä»»ä½•å…ƒç´ ã€‚
 *
 * æœ¬è´¨ä¸Šï¼Œå®ƒä»…ä¿ç•™è¿‡ç¬¬ä¸€ä¸ªæ•°ç»„ä¸­é‚£äº›åœ¨æ˜ å°„åä¸ç¬¬äºŒä¸ªæ•°ç»„æ˜ å°„ç‰ˆæœ¬ä¸­å…ƒç´ åŒ¹é…çš„å…ƒç´ ã€‚
 *
 * @category Array
 *
 * @param firstArr - the first array. ç¬¬ä¸€ä¸ªæ•°ç»„
 * @param secondArr - the second array. ç¬¬äºŒä¸ªæ•°ç»„
 * @param mapper - the mapper function. æ˜ å°„å‡½æ•°
 * @returns - a new array containing elements that exist in both the first and second arrays. -- åŒ…å«åŒæ—¶å­˜åœ¨äºç¬¬ä¸€ä¸ªæ•°ç»„å’Œç¬¬äºŒä¸ªæ•°ç»„ä¸­çš„å…ƒç´ çš„æ–°æ•°ç»„
 *
 * @example
 * ```ts
 * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
 * const array2 = [{ id: 2 }, { id: 4 }]
 * const mapper = item => item.id
 * const result = differenceBy(array1, array2, mapper)
 * // -> [{ id: 2 }]
 * ```
 *
 * @example
 * ```ts
 * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
 * const array2 = [2, 4]
 * const mapper = item => (typeof item === 'object' ? item.id : item)
 * const result = differenceBy(array1, array2, mapper)
 * // -> [{ id: 2 }]
 * ```
 */
declare function intersectionBy<T, U>(firstArr: readonly T[], secondArr: readonly U[], mapper: (item: T | U) => unknown): T[];
//#endregion
//#region src/array/map-async.d.ts
/**
 * Transforms each element in an array using an async callback function and returns
 * a promise that resolves to an array of transformed values.
 *
 * ä½¿ç”¨å¼‚æ­¥å›è°ƒå‡½æ•°è½¬æ¢æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶è¿”å›ä¸€ä¸ªè§£æä¸ºè½¬æ¢åå€¼æ•°ç»„çš„ promiseã€‚
 *
 * @example
 * ```ts
 * const users = [{ id: 1 }, { id: 2 }, { id: 3 }];
 * const userDetails = await mapAsync(users, async (user) => {
 *   return await fetchUserDetails(user.id);
 * });
 * // Returns: [{ id: 1, name: '...' }, { id: 2, name: '...' }, { id: 3, name: '...' }]
 * ```
 *
 * @example
 * ```ts
 * // With concurrency limit
 * const numbers = [1, 2, 3, 4, 5];
 * const results = await mapAsync(
 *   numbers,
 *   async (n) => await slowOperation(n),
 *   2
 * );
 * // Processes at most 2 operations concurrently
 * ```
 */
declare function mapAsync<T>(array: readonly T[], predicate: (item: T, index: number, array: readonly T[]) => Promise<T>, concurrency?: number): Promise<T[]>;
//#endregion
//#region src/array/move.d.ts
/**
 * Move item in an array
 *
 * ç§»åŠ¨æ•°ç»„ä¸­çš„é¡¹
 *
 * @category Array
 *
 * @param arr - the array
 * @param from - the index of the item to move. è¦ç§»åŠ¨çš„é¡¹çš„ç´¢å¼•
 * @param to - the index to move to. è¦ç§»åŠ¨åˆ°çš„ç´¢å¼•
 * @returns the array with the item moved. è¿”å›ç§»åŠ¨åçš„æ•°ç»„
 * @example
 * ```ts
 * move([1, 2, 3], 0, 2) // => [3, 1, 2]
 * ```
 */
declare function move<T>(arr: T[], from: number, to: number): T[];
//#endregion
//#region src/types/basic.d.ts
/**
 * Prettifies the type of an object
 *
 * Make complex intersection types display as more readable flattened structures in the IDE
 *
 * ç¾åŒ–å¯¹è±¡çš„ç±»å‹
 *
 * ä½¿å¤æ‚çš„äº¤å‰ç±»å‹åœ¨IDEä¸­æ˜¾ç¤ºä¸ºæ›´æ˜“è¯»çš„æ‰å¹³ç»“æ„
 *
 * @category Types
 *
 * @example
 * ```ts
 * type ComplexType = { name: string } & { age: number } & { address: string }
 * // display as -> { name: string } & { age: number } & { address: string }
 * // use `Prettify`
 * type PrettyType = Prettify<{ name: string } & { age: number } & { address: string }>
 * // display as -> { name: string; age: number; address: string }
 * ```
 */
type Prettify<T> = { [K in keyof T]: T[K] } & {};
/**
 * Primitive types
 */
type Primitive = null | undefined | string | number | boolean | symbol | bigint;
/**
 * Constructor
 * @category Types
 */
type Constructor<T = void> = new (...arg: any[]) => T;
/**
 * Infers the element type of an array
 * @category Types
 */
type ElementOf<T> = T extends (infer E)[] ? E : never;
/**
 * make keys required but keep undefined values
 *
 * ä½¿é”®æˆä¸ºå¿…éœ€ä½†ä¿ç•™ undefined å€¼
 *
 * @category Types
 */
type LooseRequired<T> = { [P in keyof (T & Required<T>)]: T[P] };
/**
 * Negate a boolean type
 *
 * @category Types
 */
type Not<A extends boolean> = A extends true ? false : A extends false ? true : never;
//#endregion
//#region src/types/fn.d.ts
/**
 * Promise, or maybe not
 * @category Types
 */
type Awaitable<T> = T | PromiseLike<T>;
/**
 * Function
 * @category Types
 */
type Fn<T = void> = (...args: any[]) => T;
/**
 * Async Function
 * @category Types
 */
type AsyncFn<T = void> = (...args: any[]) => Promise<T>;
/**
 * The return type of an async function
 * @category Types
 */
type AsyncReturnType<T extends AsyncFn> = Awaited<ReturnType<T>>;
//#endregion
//#region src/types/guard.d.ts
/**
 * null or whatever
 * @category Types
 */
type Nullable<T> = T | null | undefined;
/**
 * array or not yet
 * @category Types
 */
type Arrayable<T> = T | T[];
//#endregion
//#region src/types/numeric.d.ts
type _Numeric = number | bigint;
type Zero = 0 | 0n;
/**
 * Matches the hidden `Infinity` type.
 *
 * åŒ¹é…éšè—çš„ `Infinity` ç±»å‹ã€‚
 *
 * @see https://github.com/microsoft/TypeScript/issues/31752
 *
 * @category Types
 */
type PositiveInfinity = 1e999;
/**
 * Matches the hidden `-Infinity` type.
 *
 * åŒ¹é…éšè—çš„ `-Infinity` ç±»å‹ã€‚
 *
 * @see https://github.com/microsoft/TypeScript/issues/31752
 *
 * @category Types
 */
type NegativeInfinity = -1e999;
/**
 * A finite `number`.
 *
 * You can't pass a `bigint` as they are already guaranteed to be finite.
 *
 * Use-case: Validating and documenting parameters.
 *
 * ä¸€ä¸ªæœ‰é™çš„`æ•°å­—`ã€‚
 *
 * ä½ ä¸èƒ½ä¼ é€’`bigint`ï¼Œå› ä¸ºå®ƒä»¬å·²ç»è¢«ä¿è¯æ˜¯æœ‰é™çš„ã€‚
 *
 * ä½¿ç”¨åœºæ™¯ï¼šéªŒè¯å’Œè®°å½•å‚æ•°ã€‚
 *
 * @category Types
 *
 * @example
 * ```ts
 * declare function setScore<T extends number>(length: Finite<T>): void;
 * ```
 */
type Finite<T extends number> = T extends PositiveInfinity | NegativeInfinity ? never : T;
/**
 * A negative `number`/`bigint` (`-âˆ < x < 0`)
 *
 * è´Ÿæ•° `number`/`bigint`ï¼ˆ`-âˆ < x < 0`ï¼‰
 *
 * @category Types
 */
type Negative<T extends _Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never;
/**
 * A `number` that is an integer.
 *
 * ä¸€ä¸ªæ•´æ•°ç±»å‹çš„`number`ã€‚
 *
 * @category Types
 */
type Integer<T> = T extends unknown ? IsInteger<T> extends true ? T : never : never;
/**
 * A negative (`-âˆ < x < 0`) `number` that is an integer.
 * Equivalent to `Negative<Integer<T>>`.
 *
 * ä¸€ä¸ªè´Ÿæ•°ï¼ˆ`-âˆ < x < 0`ï¼‰ï¼Œä¸”æ˜¯æ•´æ•°çš„`number`ã€‚
 * ç­‰åŒäº`Negative<Integer<T>>`ã€‚
 */
type NegativeInteger<T extends number> = Negative<Integer<T>>;
/**
 * A `number` that is a float.
 *
 * ä¸€ä¸ªæµ®ç‚¹æ•°ç±»å‹çš„`number`ã€‚
 *
 * @category Types
 */
type Float<T> = T extends unknown ? IsFloat<T> extends true ? T : never : never;
/**
 * A negative (`-âˆ < x < 0`) `number` that is not an integer.
 * Equivalent to `Negative<Float<T>>`.
 *
 * ä¸€ä¸ªéæ•´æ•°çš„è´Ÿæ•°ï¼ˆ`-âˆ < x < 0`ï¼‰`number`ã€‚
 * ç­‰åŒäº `Negative<Float<T>>`ã€‚
 */
type NegativeFloat<T extends number> = Negative<Float<T>>;
//#endregion
//#region src/types/is.d.ts
/**
 * If the type T accepts type `Primitive`, output type true, otherwise output type false.
 *
 * `type Primitive = string | number | boolean | bigint | symbol | null | undefined`
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `Primitive`ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @category Types
 */
type IsPrimitive<T> = [T] extends [Primitive] ? true : false;
/**
 * If the type T accepts type "any", output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹Tæ¥å—ç±»å‹"any"ï¼Œåˆ™è¾“å‡ºç±»å‹trueï¼Œå¦åˆ™è¾“å‡ºç±»å‹falseã€‚
 *
 * @see https://stackoverflow.com/a/49928360/1490091
 *
 * @category Types
 */
type IsAny<T> = 0 extends 1 & NoInfer<T> ? true : false;
/**
 * If the type T accepts type `never`, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `never`ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @see https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
 * @see https://stackoverflow.com/a/53984913/10292952
 *
 * @category Types
 */
type IsNever<T> = [T] extends [never] ? true : false;
/**
 * If the type T accepts type `null`, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `null`ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @category Types
 */
type IsNull<T> = [T] extends [null] ? true : false;
/**
 * If the type T accepts type `null`, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ T åŒ…å«ç±»å‹ `null`ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @example
 * ```ts
 * type A = IsNullable<string>;
 * //=> false
 *
 * type B = IsNullable<string | null>;
 * //=> true
 * ```
 *
 * @category Types
 */
type IsNullable<T> = IsAny<T> extends true ? true : Extract<T, null> extends never ? false : true;
/**
 * If the type T accepts type `undefined`, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `undefined`ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @category Types
 */
type IsUndefined<T> = [T] extends [undefined] ? true : false;
/**
 * If the type T accepts type `unknown`, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `unknown`ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @category Types
 */
type IsUnknown<T> = unknown extends T ? IsNull<T> extends false ? true : false : false;
/**
 * If the type T is a union type, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ T æ˜¯è”åˆç±»å‹ï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @category Types
 */
type IsUnion<T> = InternalIsUnion<T>;
/**
 * The actual implementation of `IsUnion`.
 *
 * `IsUnion` çš„å®é™…å®ç°ã€‚
 */
type InternalIsUnion<T, U = T> = (IsNever<T> extends true ? false : T extends any ? [U] extends [T] ? false : true : never) extends infer Result ? boolean extends Result ? true : Result : never;
/**
 * If the type X is equal to the type Y, output type true, otherwise output type false.
 *
 * å¦‚æœç±»å‹ X ç­‰äºç±»å‹ Yï¼Œåˆ™è¾“å‡º trueï¼Œå¦åˆ™è¾“å‡º falseã€‚
 *
 * @category Types
 */
type IsEqual<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
/**
 * Returns a boolean for whether the given `boolean` is not `false`.
 *
 * è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºç»™å®šçš„`boolean`æ˜¯å¦ä¸ä¸º`false`ã€‚
 *
 * @category Types
 */
type IsNotFalse<T extends boolean> = [T] extends [false] ? false : true;
/**
 * Returns a boolean for whether the given type is `any` or `never`.
 *
 * This type can be better to use than {@link IfNotAnyOrNever `IfNotAnyOrNever`} in recursive types because it does not evaluate any branches.
 *
 * è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œç”¨äºåˆ¤æ–­ç»™å®šç±»å‹æ˜¯å¦ä¸º `any` æˆ– `never`ã€‚
 *
 * åœ¨é€’å½’ç±»å‹ä¸­ä½¿ç”¨æ­¤ç±»å‹æ¯”ä½¿ç”¨ {@link IfNotAnyOrNever} æ›´ä¼˜ï¼Œå› ä¸ºå®ƒä¸ä¼šè¯„ä¼°ä»»ä½•åˆ†æ”¯ã€‚
 *
 * @example
 * ```
 * // When `T` is a NOT `any` or `never` (like `string`) => Returns `false`
 * type A = IsAnyOrNever<string>;
 * //=> false
 *
 * // When `T` is `any` => Returns `true`
 * type B = IsAnyOrNever<any>;
 * //=> true
 *
 * // When `T` is `never` => Returns `true`
 * type C = IsAnyOrNever<never>;
 * //=> true
 * ```
 *
 * @category Types
 */
type IsAnyOrNever<T> = IsNotFalse<IsAny<T> | IsNever<T>>;
/**
 * Returns a boolean for whether the given number is a float, like `1.5` or `-1.5`.
 *
 * è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºç»™å®šçš„æ•°å­—æ˜¯å¦ä¸ºæµ®ç‚¹æ•°ï¼Œä¾‹å¦‚ `1.5` æˆ– `-1.5`ã€‚
 *
 * @category Types
 */
type IsFloat<T> = T extends number ? `${T}` extends `${number}e${infer E extends '-' | '+'}${number}` ? E extends '-' ? true : false : `${T}` extends `${number}.${number}` ? true : false : false;
type IsInteger<T> = T extends bigint ? true : T extends number ? number extends T ? false : T extends PositiveInfinity | NegativeInfinity ? false : Not<IsFloat<T>> : false;
//#endregion
//#region src/types/if.d.ts
/**
 * An if-else-like type that resolves depending on whether the given `boolean` type is `true` or `false`.
 *
 * Use-cases:
 * - You can use this in combination with `Is*` types to create an if-else-like experience. For example, `If<IsAny<any>, 'is any', 'not any'>`.
 *
 * ä¸€ç§ç±»ä¼¼if-elseçš„ç±»å‹ï¼Œæ ¹æ®ç»™å®šçš„`boolean`ç±»å‹æ˜¯`true`è¿˜æ˜¯`false`æ¥è§£æã€‚
 *
 * ç”¨ä¾‹ï¼š
 * - ä½ å¯ä»¥å°†æ­¤ä¸ `Is*` ç±»å‹ç»“åˆä½¿ç”¨ï¼Œä»¥åˆ›å»ºç±»ä¼¼ if-else çš„èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œ`If<IsAny<any>, 'is any', 'not any'>`ã€‚
 *
 * @category Types
 */
type If<T extends boolean, Y, N> = IsNever<T> extends true ? N : T extends true ? Y : N;
/**
 * If the type T accepts type "any", output type Y, otherwise output type N.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹"any"ï¼Œåˆ™è¾“å‡ºç±»å‹ Y ï¼Œå¦åˆ™è¾“å‡ºç±»å‹ N ã€‚
 *
 * @see https://stackoverflow.com/questions/49927523/disallow-call-with-any/49928360#49928360
 *
 * @category Types
 *
 */
type IfAny<T, Y, N> = If<IsAny<T>, Y, N>;
/**
 * If the type T accepts type `null`, output type Y, otherwise output type N.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `null`ï¼Œåˆ™è¾“å‡ºç±»å‹ Yï¼Œå¦åˆ™è¾“å‡ºç±»å‹ Nã€‚
 *
 * @category Types
 */
type IfNull<T, Y = true, N = false> = If<IsNull<T>, Y, N>;
/**
 * If the type T accepts type `undefined`, output type Y, otherwise output type N.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `undefined`ï¼Œåˆ™è¾“å‡ºç±»å‹ Yï¼Œå¦åˆ™è¾“å‡ºç±»å‹ Nã€‚
 *
 * @category Types
 */
type IfUndefined<T, Y = true, N = false> = If<IsUndefined<T>, Y, N>;
/**
 * If the type T accepts type `never`, output type Y, otherwise output type N.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `never`ï¼Œåˆ™è¾“å‡ºç±»å‹ Yï¼Œå¦åˆ™è¾“å‡ºç±»å‹ Nã€‚
 *
 * @category Types
 */
type IfNever<T, Y = true, N = false> = If<IsNever<T>, Y, N>;
/**
 * If the type T accepts type `unknown`, output type Y, otherwise output type N.
 *
 * å¦‚æœç±»å‹ T æ¥å—ç±»å‹ `unknown`ï¼Œåˆ™è¾“å‡ºç±»å‹ Yï¼Œå¦åˆ™è¾“å‡ºç±»å‹ Nã€‚
 *
 * @category Types
 */
type IfUnknown<T, Y = true, N = false> = If<IsUnknown<T>, Y, N>;
/**
 * An if-else-like type that resolves depending on whether the given type is `any` or `never`.
 *
 * ä¸€ç§ç±»ä¼¼if-elseçš„ç±»å‹ï¼Œæ ¹æ®ç»™å®šç±»å‹æ˜¯`any`è¿˜æ˜¯`never`æ¥è§£æã€‚
 *
 * @example
 * ```ts
 * // When `T` is a NOT `any` or `never` (like `string`) => Returns `IfNotAnyOrNever` branch
 * type A = IfNotAnyOrNever<string, 'VALID', 'IS_ANY', 'IS_NEVER'>;
 * //=> 'VALID'
 *
 * // When `T` is `any` => Returns `IfAny` branch
 * type B = IfNotAnyOrNever<any, 'VALID', 'IS_ANY', 'IS_NEVER'>;
 * //=> 'IS_ANY'
 *
 * // When `T` is `never` => Returns `IfNever` branch
 * type C = IfNotAnyOrNever<never, 'VALID', 'IS_ANY', 'IS_NEVER'>;
 * //=> 'IS_NEVER'
 * ```
 */
type IfNotAnyOrNever<T, IfNotAnyOrNever$1, IfAny$1 = any, IfNever$1 = never> = If<IsAny<T>, IfAny$1, If<IsNever<T>, IfNever$1, IfNotAnyOrNever$1>>;
//#endregion
//#region src/types/union.d.ts
/**
 * Convert a union type to an intersection type using [distributive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).
 *
 * ä½¿ç”¨[åˆ†é…æ¡ä»¶ç±»å‹](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types)å°†è”åˆç±»å‹è½¬æ¢ä¸ºäº¤å‰ç±»å‹ã€‚
 *
 * @see https://stackoverflow.com/a/50375286/2172153
 *
 * @category Types
 */
type UnionToIntersection<Union> = (Union extends unknown ? (distributedUnion: Union) => void : never) extends ((mergedIntersection: infer Intersection) => void) ? Intersection & Union : never;
/**
 * Returns the last element of a union type.
 *
 * è¿”å›è”åˆç±»å‹çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
 */
type LastOfUnion<T> = UnionToIntersection<T extends any ? () => T : never> extends (() => (infer R)) ? R : never;
/**
 * Convert a union type into an unordered tuple type of its elements.
 *
 * "Unordered" means the elements of the tuple are not guaranteed to be in the same order as in the union type. The arrangement can appear random and may change at any time.
 *
 * This can be useful when you have objects with a finite set of keys and want a type defining only the allowed keys, but do not want to repeat yourself.
 *
 * å°†è”åˆç±»å‹è½¬æ¢ä¸ºå…¶å…ƒç´ çš„æ— åºå…ƒç»„ç±»å‹ã€‚
 *
 * â€œæ— åºâ€æ„å‘³ç€å…ƒç»„ä¸­çš„å…ƒç´ ä¸ä¸€å®šä¸è”åˆç±»å‹ä¸­çš„é¡ºåºç›¸åŒã€‚æ’åˆ—å¯ä»¥æ˜¾å¾—éšæœºï¼Œå¹¶ä¸”å¯èƒ½ä¼šéšæ—¶æ”¹å˜ã€‚
 *
 * å½“ä½ æœ‰å…·æœ‰æœ‰é™é”®é›†çš„å¯¹è±¡ï¼Œå¹¶ä¸”å¸Œæœ›å®šä¹‰ä»…å…è®¸çš„é”®çš„ç±»å‹ï¼Œä½†åˆä¸æƒ³é‡å¤è‡ªå·±æ—¶ï¼Œè¿™ä¼šå¾ˆæœ‰ç”¨ã€‚
 *
 * @category Types
 *
 * @example
 * ```ts
 * type Numbers = 1 | 2 | 3
 * type NumbersTuple = UnionToTuple<Numbers>
 * //=> [1, 2, 3]
 * ```
 *
 * @example
 * ```ts
 * const pets = {
 *   dog: 'ğŸ¶',
 *   cat: 'ğŸ±',
 *   snake: 'ğŸ',
 * }
 *
 * type Pet = keyof typeof pets;
 * //=> 'dog' | 'cat' | 'snake'
 *
 * const petList = Object.keys(pets) as UnionToTuple<Pet>;
 * //=> ['dog', 'cat', 'snake']
 * ```
 */
type UnionToTuple<T, L = LastOfUnion<T>> = IsNever<T> extends false ? [...UnionToTuple<Exclude<T, L>>, L] : [];
/**
 * A literal type that supports custom further strings but preserves autocompletion in IDEs.
 *
 * æ”¯æŒè‡ªå®šä¹‰è¿›ä¸€æ­¥å­—ç¬¦ä¸²ä½†ä¿ç•™IDEè‡ªåŠ¨å®Œæˆçš„å­—é¢é‡ç±»å‹ã€‚
 *
 * @see https://github.com/microsoft/TypeScript/issues/29729#issuecomment-471566609
 */
type LiteralUnion<Union extends Base, Base = string> = Union | (Base & {
  __zz_IGNORE_ME__?: never;
});
//#endregion
//#region src/array/order-by.d.ts
/**
 * Sorts an array of (objects | strings | numbers) based on the given `accords` and their corresponding order directions.
 *
 * - If you provide keys, it sorts the objects by the values of those keys.
 * - If you provide functions, it sorts based on the values returned by those functions.
 *
 * The function returns the array of (objects | strings | numbers) sorted in corresponding order directions.
 * If two objects have the same value for the current accordion, it uses the next accordion to determine their order.
 * If the number of orders is less than the number of accord, it uses the last order for the rest of the accord.
 *
 * æ ¹æ®ç»™å®šçš„`accords`åŠå…¶å¯¹åº”çš„æ’åºæ–¹å‘å¯¹ (å¯¹è±¡ | å­—ç¬¦ä¸² | æ•°å­—) æ•°ç»„è¿›è¡Œæ’åºã€‚
 *
 * - å¦‚æœæä¾›é”®åï¼Œåˆ™æŒ‰è¿™äº›é”®å¯¹åº”çš„å€¼å¯¹å¯¹è±¡è¿›è¡Œæ’åºã€‚
 * - å¦‚æœæä¾›å‡½æ•°ï¼Œåˆ™æ ¹æ®è¿™äº›å‡½æ•°è¿”å›çš„å€¼è¿›è¡Œæ’åºã€‚
 *
 * è¯¥å‡½æ•°è¿”å›æŒ‰ç›¸åº”é¡ºåºæ–¹å‘æ’åºçš„ (å¯¹è±¡ | å­—ç¬¦ä¸² | æ•°å­—) æ•°ç»„ã€‚
 * è‹¥ä¸¤ä¸ª (å¯¹è±¡ | å­—ç¬¦ä¸² | æ•°å­—) åœ¨å½“å‰æ’åºä¾æ®ä¸Šå…·æœ‰ç›¸åŒå€¼ï¼Œåˆ™ä½¿ç”¨ä¸‹ä¸€ä¸ªæ’åºä¾æ®æ¥ç¡®å®šå®ƒä»¬çš„é¡ºåºã€‚
 * è‹¥æ’åºä¾æ®çš„æ•°é‡å°‘äºæ’åºæ–¹å‘çš„æ•°é‡ï¼Œåˆ™å‰©ä½™æ’åºä¾æ®å°†æ²¿ç”¨æœ€åä¸€ä¸ªæŒ‡å®šçš„æ’åºæ–¹å‘ã€‚
 *
 * @category Array
 *
 * @example
 * ```ts
 * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.
 * const users = [
 *   { user: 'fred', age: 48 },
 *   { user: 'barney', age: 34 },
 *   { user: 'fred', age: 40 },
 *   { user: 'barney', age: 36 },
 * ];
 *
 * const result = orderBy(users, [obj => obj.user, 'age'], ['asc', 'desc']);
 * // result will be:
 * // [
 * //   { user: 'barney', age: 36 },
 * //   { user: 'barney', age: 34 },
 * //   { user: 'fred', age: 48 },
 * //   { user: 'fred', age: 40 },
 * // ]
 * ```
 */
declare function orderBy<T>(arr: readonly T[], accords: Arrayable<((item: T) => unknown) | (T extends object ? keyof T : never)>, orders?: Arrayable<'asc' | 'desc'>): T[];
//#endregion
//#region src/array/range.d.ts
/**
 * Generate a range array of numbers starting from `0`. The `stop` is exclusive.
 *
 * ä» `0` å¼€å§‹ç”Ÿæˆä¸€ä¸ªæ•°å­—èŒƒå›´çš„æ•°ç»„, `stop` æ˜¯ä¸åŒ…å«çš„ã€‚
 *
 * @category Array
 *
 * @param stop - the end of the range. èŒƒå›´ç»“æŸæ•°å­—ã€‚
 *
 * @example
 * ```ts
 * range(5) // => [0, 1, 2, 3, 4]
 * ```
 */
declare function range(stop: number): number[];
/**
 * Generate a range array of numbers. The `stop` is exclusive.
 *
 * ç”Ÿæˆä¸€ä¸ªæ•°å­—èŒƒå›´çš„æ•°ç»„, `stop` æ˜¯ä¸åŒ…å«çš„ã€‚
 *
 * @category Array
 *
 * @param start - the start of the range. èŒƒå›´å¼€å§‹æ•°å­—
 * @param stop - the end of the range. èŒƒå›´ç»“æŸæ•°å­—
 * @param step - the step of the range. æ­¥è¿›
 *
 * @example
 * ```ts
 * range(5, 10) // => [5, 6, 7, 8, 9]
 * range(5, 10, 2) // => [5, 7, 9]
 * ```
 */
declare function range(start: number, stop: number, step?: number): number[];
//#endregion
//#region src/array/remove.d.ts
/**
 * Remove value from array
 *
 * ä»æ•°ç»„ä¸­ç§»é™¤å€¼
 *
 * also see {@link removeBy}
 *
 * @category Array
 *
 * @param array - the array
 * @param value - the value to remove - å¾…ç§»é™¤çš„å€¼
 * @returns - if `true`, the value is removed, `false` otherwise.
 *          - å¦‚æœæˆåŠŸç§»é™¤,è¿”å› `true`, å¦åˆ™è¿”å› `false`
 *
 * @example
 * ```ts
 * const arr = [1, 2, 3]
 * remove(arr, 2) // => true
 * console.log(arr) // => [1, 3]
 * remove(arr, 4) // => false
 * ```
 */
declare function remove<T>(array: T[], value: T): boolean;
/**
 * Remove value by predicate function from array
 *
 * é€šè¿‡ predicate æ–¹æ³•ï¼Œä»æ•°ç»„ä¸­ç§»é™¤å€¼
 *
 * also see {@link remove}
 *
 * @category Array
 *
 * @param array - the array
 * @param predicate - the predicate function
 * @returns - if `true`, the value is removed, `false` otherwise.
 *          - å¦‚æœæˆåŠŸç§»é™¤,è¿”å› `true`, å¦åˆ™è¿”å› `false`
 *
 * @example
 * ```ts
 * const arr = [1, 2, 3]
 * removeBy(arr, n => n === 2) // => true
 * console.log(arr) // => [1, 3]
 * ```
 *
 * @example
 * ```ts
 * const arr = [
 *   { id: 1, csv: 1 },
 *   { id: 2, csv: 1 },
 *   { id: 3, csv: 1 },
 * ]
 * removeBy(arr, item => item.id === 2) // => true
 * console.log(arr) // => [{ id: 1, csv: 1 }, { id: 3, csv: 1 }]
 * ```
 */
declare function removeBy<T>(array: T[], predicate: (item: T, index: number, array: readonly T[]) => boolean): boolean;
//#endregion
//#region src/array/shuffle.d.ts
/**
 * Shuffle array
 *
 * æ•°ç»„æ´—ç‰Œï¼Œéšæœºæ‰“ä¹±æ•°ç»„ä¸­çš„é¡ºåº
 *
 * @category Array
 * @example
 * ```ts
 * shuffle([1, 2, 3]) // => [1, 3, 2]
 * ```
 */
declare function shuffle<T>(array: T[]): T[];
//#endregion
//#region src/array/sort-by.d.ts
/**
 * Sorts an array of (objects | strings | numbers) based on the given `accords`.
 *
 * - If you provide keys, it sorts the objects by the values of those keys.
 * - If you provide functions, it sorts based on the values returned by those functions.
 *
 * The function returns the array of (objects | strings | numbers) sorted in ascending order.
 * If two (objects | strings | numbers) the same value for the current accordion, it uses the next accordion to determine their order.
 *
 * æ ¹æ®ç»™å®šçš„`accords`å¯¹ (objects | strings | numbers) æ•°ç»„è¿›è¡Œæ’åºã€‚
 *
 * - å¦‚æœæä¾›é”®åï¼Œåˆ™æŒ‰è¿™äº›é”®å¯¹åº”çš„å€¼å¯¹å¯¹è±¡è¿›è¡Œæ’åºã€‚
 * - å¦‚æœæä¾›å‡½æ•°ï¼Œåˆ™æ ¹æ®è¿™äº›å‡½æ•°è¿”å›çš„å€¼è¿›è¡Œæ’åºã€‚
 *
 * è¯¥å‡½æ•°è¿”å›æŒ‰å‡åºæ’åºçš„ (objects | strings | numbers) æ•°ç»„ã€‚
 * è‹¥ä¸¤ä¸ª (objects | strings | numbers) åœ¨å½“å‰æ’åºä¾æ®ä¸Šå…·æœ‰ç›¸åŒå€¼ï¼Œåˆ™ä½¿ç”¨ä¸‹ä¸€ä¸ªæ’åºä¾æ®æ¥ç¡®å®šå®ƒä»¬çš„é¡ºåºã€‚
 *
 * @category Array
 *
 * @example
 * ```ts
 * const users = [
 *  { user: 'foo', age: 24 },
 *  { user: 'bar', age: 7 },
 *  { user: 'foo', age: 8 },
 *  { user: 'bar', age: 29 },
 * ];
 *
 * sortBy(users, ['user', 'age']);
 * sortBy(users, [obj => obj.user, 'age']);
 * // results will be:
 * // [
 * //   { user : 'bar', age: 7 },
 * //   { user : 'bar', age: 29 },
 * //   { user : 'foo', age: 8 },
 * //   { user : 'foo', age: 24 },
 * // ]
 * ```
 */
declare function sortBy<T>(arr: readonly T[], accords: Arrayable<((item: T) => unknown) | (T extends object ? keyof T : never)>): T[];
//#endregion
//#region src/array/to-array.d.ts
/**
 * Convert `Arrayable<T>` to `Array<T>`
 *
 * å°† `Arrayable<T>` è½¬æ¢ä¸º `Array<T>`
 *
 * @category Array
 *
 * @example
 * ```ts
 * toArray(null) // => []
 * toArray(undefined) // => []
 * toArray([]) // => []
 * toArray(1) // => [1]
 * toArray([1]) // => [1]
 * ```
 */
declare function toArray<T>(v: Nullable<Arrayable<T>>): T[];
//#endregion
//#region src/array/union.d.ts
/**
 * Union two arrays
 *
 * ä¸¤ä¸ªæ•°ç»„çš„å¹¶é›†
 *
 * @category Array
 *
 * @example
 * ```ts
 * union([1, 2, 3], [2, 4, 5, 6]) // => [1, 2, 3, 4, 5, 6]
 * union([1, 2], [3, 4]) // => []
 * ```
 */
declare function union<T>(a: T[], b: T[]): T[];
declare function unionBy<T, U>(a: T[], b: T[], predicate: (item: T) => U): T[];
//#endregion
//#region src/array/uniq.d.ts
/**
 * Unique array by array element
 *
 * é€šè¿‡æ•°ç»„å…ƒç´ çš„ç›¸åŒæ€§æ¥å®ç°æ•°ç»„å»é‡
 *
 * @category Array
 * @example
 * ```ts
 * uniq([1, 1, 2, 2, 3, 3]) // => [1, 2, 3]
 * ```
 */
declare function uniq<T>(v: T[]): T[];
/**
 * Unique array by a custom predicate function
 *
 * é€šè¿‡è‡ªå®šä¹‰ predicate å‡½æ•°å®ç°æ•°ç»„å»é‡
 *
 * @category Array
 * @example
 * ```ts
 * uniqBy([
 *  { id: 1, name: 'John' },
 *  { id: 2, name: 'Mark' },
 *  { id: 3, name: 'John' },
 * ], item => item.name)
 * // => [{ id: 1, name: 'John' }, { id: 2, name: 'Mark' }]
 * ```
 * @example
 * ```ts
 * uniqBy([1.1, 1.2, 2.1, 2.2], Math.floor)
 * // => [1.1, 2.1]
 * ```
 */
declare function uniqBy<T, U>(v: readonly T[], predicate: (item: T) => U): T[];
/**
 * Unique array with a custom equality function
 *
 * é€šè¿‡è‡ªå®šä¹‰ç›¸ç­‰å‡½æ•°å®ç°æ•°ç»„å»é‡
 *
 * @category Array
 * @example
 * ```ts
 * uniqWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)
 * // => [1, 2, 3]
 * ```
 */
declare function uniqWith<T>(array: readonly T[], equal: (a: T, b: T) => boolean): T[];
//#endregion
//#region src/date/is-same-day.d.ts
/**
 * Check if two dates is same day
 * @category Date
 */
declare function isSameDay(date1: Date | number | string, date2?: Date | number | string): boolean;
//#endregion
//#region src/date/timestamp.d.ts
/**
 * Get current timestamp
 *
 * è·å–å½“å‰æ—¶é—´æˆ³
 *
 * @category Date
 */
declare function timestamp(): number;
//#endregion
//#region src/event/emitter.d.ts
type EventType = string | symbol;
type EventListener<T> = (event: T) => void;
type EventWildcardListener<T = Record<string, unknown>> = (type: keyof T, event: T[keyof T]) => void;
type EventListenerList<T> = EventListener<T>[];
type EventWildcardListenerList<T> = EventWildcardListener<T>[];
type EventListenerMap<T extends Record<EventType, unknown>> = Map<keyof T | '*', EventListenerList<T[keyof T]> | EventWildcardListenerList<T>>;
interface EventEmitter<Events extends Record<EventType, unknown>> {
  listeners: EventListenerMap<Events>;
  /**
   * Adds a listener to the specified event.
   *
   * @param type - the event to listen for
   *               - '*' to listen for wildcard event
   * @param listener - the listener function to be called when the event is triggered
   * @return
   */
  on<Key extends keyof Events>(type: Key, listener: EventListener<Events[Key]>): void;
  on(type: '*', listener: EventWildcardListener<Events>): void;
  /**
   * Turn off the specified event listener.
   * @param type - the name of the event to turn off
   *               - '*' to turn off wildcard event
   * @param listener - (optional) the listener function to turn off
   */
  off<Key extends keyof Events>(type: Key, listener?: EventListener<Events[Key]>): void;
  off(type: '*', listener: EventWildcardListener<Events>): void;
  /**
   * Adds a listener to the specified event, the listener will be called only once.
   * @param type - the event to listen for
   *               - '*' to listen for wildcard event
   * @param listener - the listener function to be called when the event is triggered
   */
  once<Key extends keyof Events>(type: Key, listener: EventListener<Events[Key]>): void;
  once(type: '*', listener: EventWildcardListener<Events>): void;
  /**
   * Emits the specified event with the given arguments to all registered listeners.
   * @param type - the name of the event to emit, wildcard event will be after emitted
   * @param event - the arguments to pass to the event listeners
   */
  emit<Key extends keyof Events>(type: Key, event: Events[Key]): void;
  emit<Key extends keyof Events>(type: undefined extends Events[Key] ? Key : never): void;
}
/**
 * Create an event emitter
 *
 * åˆ›å»ºä¸€ä¸ªäº‹ä»¶å‘å°„å™¨
 *
 * @category Event
 *
 * @example
 * ```ts
 * const emitter = createEmitter()
 *
 * // listen for an event
 * emitter.on('event-name', (data) => console.log(data))
 *
 * // emit an event
 * emitter.emit('event-name', data)
 * ```
 */
declare function createEmitter<Events extends Record<EventType, unknown>>(listeners?: EventListenerMap<Events>): EventEmitter<Events>;
//#endregion
//#region src/function/compose.d.ts
type ComposeFn = (...args: any[]) => any;
type LastArray<T extends any[]> = T extends [...any[], infer U] ? U : Fn;
type FirstArray<T extends any[]> = T extends [infer U, ...any[]] ? U : Fn;
/**
 * compose multiple functions, right to left
 *
 * ç»„åˆå¤šä¸ªå‡½æ•°ï¼Œä»å³åˆ°å·¦æ‰§è¡Œ
 *
 * @category Function
 * @example
 * ```ts
 * const add = (a) => a + 1
 * const subtract = (a) => a - 2
 * const multiply = (a, b) => a * b
 * compose(add, subtract, multiply)(1, 2) // => (1 * 2) - 2 + 1 = 1
 * ```
 */
declare function compose<T extends ComposeFn[] = ComposeFn[]>(...fns: T): (...args: Parameters<LastArray<T>>) => ReturnType<FirstArray<T>>;
//#endregion
//#region src/_internal/types.d.ts
interface CancelOptions {
  upcomingOnly?: boolean;
}
interface Cancel {
  cancel: (options?: CancelOptions) => void;
}
interface FnNoReturn<T extends (...args: any[]) => any> {
  (...args: Parameters<T>): void;
}
//#endregion
//#region src/function/debounce.d.ts
/**
 * Debounce Options
 * @category Types
 */
interface DebounceOptions {
  /**
   * If atBegin is false or unspecified, callback will only be executed `delay`
   * milliseconds after the last debounced-function call. If atBegin is true,
   * callback will be executed only at the first debounced-function call. (After
   * the throttled-function has not been called for `delay` milliseconds, the
   * internal counter is reset).
   *
   * å¦‚æœatBeginä¸ºfalseæˆ–æœªæŒ‡å®šï¼Œå›è°ƒå‡½æ•°ä»…åœ¨æœ€åä¸€æ¬¡é˜²æŠ–å‡½æ•°è°ƒç”¨åçš„`delay`æ¯«ç§’æ‰§è¡Œã€‚
   * å¦‚æœatBeginä¸ºtrueï¼Œå›è°ƒå‡½æ•°ä»…åœ¨ç¬¬ä¸€æ¬¡é˜²æŠ–å‡½æ•°è°ƒç”¨æ—¶æ‰§è¡Œã€‚
   * ï¼ˆåœ¨èŠ‚æµå‡½æ•°æœªè¢«è°ƒç”¨`delay`æ¯«ç§’åï¼Œå†…éƒ¨è®¡æ•°å™¨å°†è¢«é‡ç½®ï¼‰ã€‚
   */
  atBegin?: boolean;
}
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * é˜²æŠ–å‡½æ•°çš„æ‰§è¡Œã€‚ä¸èŠ‚æµä¸åŒï¼Œé˜²æŠ–ç¡®ä¿ä¸€ä¸ªå‡½æ•°åœ¨ä¸€ç³»åˆ—è°ƒç”¨ä¸­ä»…æ‰§è¡Œä¸€æ¬¡ï¼Œ
 * è¦ä¹ˆåœ¨è°ƒç”¨çš„æœ€å¼€å§‹ï¼Œè¦ä¹ˆåœ¨è°ƒç”¨çš„æœ€æœ«å°¾ã€‚
 *
 * @category Functions
 *
 * @param delay
 * A zero-or-greater delay in milliseconds. For event callbacks, values around
 * 100 or 250 (or even higher) are most useful.
 *
 * ä¸€ä¸ªé›¶æˆ–æ›´å¤§çš„å»¶è¿Ÿï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚å¯¹äºäº‹ä»¶å›è°ƒï¼Œå¤§çº¦ 100 æˆ– 250ï¼ˆç”šè‡³æ›´é«˜ï¼‰çš„å€¼æœ€ä¸ºå®ç”¨ã€‚
 *
 * @param callback
 * A function to be executed after delay milliseconds. The `this` context and
 * all arguments are passed through, as-is, to `callback` when the
 * debounced-function is executed.
 *
 * ä¸€ä¸ªåœ¨å»¶è¿Ÿæ¯«ç§’åæ‰§è¡Œçš„å‡½æ•°ã€‚å½“é˜²æŠ–å‡½æ•°æ‰§è¡Œæ—¶ï¼Œ`this`ä¸Šä¸‹æ–‡å’Œæ‰€æœ‰å‚æ•°éƒ½ä¼šåŸæ ·ä¼ é€’ç»™`callback`ã€‚
 *
 * @param options
 * An object to configure options.
 * ç”¨äºé…ç½®é€‰é¡¹çš„å¯¹è±¡ã€‚
 *
 * @return
 * A new, debounced function.
 */
declare function debounce<T extends (...args: any[]) => any>(delay: number, callback: T, options?: DebounceOptions): FnNoReturn<T> & Cancel;
//#endregion
//#region src/function/invoke.d.ts
/**
 * call the function
 *
 * è°ƒç”¨å‡½æ•°
 *
 * @category Function
 */
declare function invoke<T>(fn: Fn<T>, ...args: any): T;
/**
 * call every functions in an array, the remaining parameters are passed in turn
 *
 * è°ƒç”¨æ•°ç»„ä¸­çš„æ¯ä¸ªå‡½æ•°ï¼Œå‰©ä½™å‚æ•°ä¾æ¬¡ä¼ å…¥
 *
 * @category Function
 *
 * @param fns - an array of functions
 */
declare function invoke(fns: Nullable<Fn>[], ...args: any[]): void;
//#endregion
//#region src/function/noop.d.ts
/**
 * noop function
 *
 * ç©ºå‡½æ•°
 *
 * @category Function
 */
declare function noop(): void;
//#endregion
//#region src/function/once.d.ts
/**
 * Create a function that can only be called once,
 * and repeated calls return the result of the first call
 *
 * åˆ›å»ºåªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡çš„å‡½æ•°ï¼Œé‡å¤è°ƒç”¨è¿”å›ç¬¬ä¸€æ¬¡è°ƒç”¨çš„ç»“æœ
 *
 * @category Function
 */
declare function once<T extends (...args: any[]) => any>(func: T): T;
//#endregion
//#region src/function/throttle.d.ts
/**
 * Throttle Options
 * @category Types
 */
interface ThrottleOptions {
  /**
   * Optional, defaults to false. If noTrailing is true, callback will only execute
   * every `delay` milliseconds while the throttled-function is being called. If
   * noTrailing is false or unspecified, callback will be executed one final time
   * after the last throttled-function call. (After the throttled-function has not
   * been called for `delay` milliseconds, the internal counter is reset)
   *
   * å¯é€‰ï¼Œé»˜è®¤ä¸ºfalseã€‚å¦‚æœnoTrailingä¸ºtrueï¼Œå›è°ƒå‡½æ•°ä»…åœ¨èŠ‚æµå‡½æ•°è¢«è°ƒç”¨æ—¶æ¯`delay`æ¯«ç§’æ‰§è¡Œä¸€æ¬¡ã€‚
   * å¦‚æœnoTrailingä¸ºfalseæˆ–æœªæŒ‡å®šï¼Œå›è°ƒå‡½æ•°å°†åœ¨æœ€åä¸€æ¬¡èŠ‚æµå‡½æ•°è°ƒç”¨åé¢å¤–æ‰§è¡Œä¸€æ¬¡ã€‚
   * ï¼ˆå½“èŠ‚æµå‡½æ•°åœ¨`delay`æ¯«ç§’å†…æœªè¢«è°ƒç”¨æ—¶ï¼Œå†…éƒ¨è®¡æ•°å™¨å°†è¢«é‡ç½®ï¼‰
   */
  noTrailing?: boolean;
  /**
   * Optional, defaults to false. If noLeading is false, the first throttled-function
   * call will execute callback immediately. If noLeading is true, the first the
   * callback execution will be skipped. It should be noted that callback will never
   * executed if both noLeading = true and noTrailing = true.
   *
   * å¯é€‰ï¼Œé»˜è®¤ä¸ºfalseã€‚å¦‚æœnoLeadingä¸ºfalseï¼Œç¬¬ä¸€æ¬¡èŠ‚æµå‡½æ•°è°ƒç”¨å°†ç«‹å³æ‰§è¡Œå›è°ƒã€‚
   * å¦‚æœnoLeadingä¸ºtrueï¼Œç¬¬ä¸€æ¬¡å›è°ƒæ‰§è¡Œå°†è¢«è·³è¿‡ã€‚
   * éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœnoLeading = trueä¸”noTrailing = trueï¼Œå›è°ƒå°†æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œã€‚
   */
  noLeading?: boolean;
  /**
   * If `debounceMode` is true (at begin), schedule
   * `callback` to execute after `delay` ms. If `debounceMode` is false (at end),
   * schedule `callback` to execute after `delay` ms.
   *
   * å¦‚æœ `debounceMode` ä¸º trueï¼ˆåœ¨å¼€å§‹æ—¶ï¼‰ï¼Œåˆ™å®‰æ’
   * `callback` åœ¨ `delay` æ¯«ç§’åæ‰§è¡Œã€‚å¦‚æœ `debounceMode` ä¸º falseï¼ˆåœ¨ç»“æŸæ—¶ï¼‰ï¼Œ
   * å®‰æ’ `callback` åœ¨ `delay` æ¯«ç§’åæ‰§è¡Œã€‚
   */
  debounceMode?: boolean;
}
/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * é™åˆ¶å‡½æ•°çš„æ‰§è¡Œé¢‘ç‡ã€‚ç‰¹åˆ«é€‚ç”¨äºé™åˆ¶äº‹ä»¶å¤„ç†ç¨‹åºçš„æ‰§è¡Œé€Ÿç‡ï¼Œä¾‹å¦‚è°ƒæ•´å¤§å°å’Œæ»šåŠ¨äº‹ä»¶ã€‚
 *
 * @category Function
 *
 * @param delay
 * A zero-or-greater delay in milliseconds. For event callbacks, values around
 * 100 or 250 (or even higher) are most useful.
 *
 * ä¸€ä¸ªé›¶æˆ–æ›´å¤§çš„å»¶è¿Ÿæ—¶é—´ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚å¯¹äºäº‹ä»¶å›è°ƒï¼Œå¤§çº¦
 * 100æˆ–250ï¼ˆç”šè‡³æ›´é«˜ï¼‰çš„å€¼æœ€ä¸ºå®ç”¨ã€‚
 *
 * @param callback
 * A function to be executed after delay milliseconds. The `this` context and
 * all arguments are passed through, as-is, to `callback` when the
 * throttled-function is executed.
 *
 * ä¸€ä¸ªåœ¨å»¶è¿Ÿæ¯«ç§’åæ‰§è¡Œçš„å‡½æ•°ã€‚
 * å½“èŠ‚æµå‡½æ•°æ‰§è¡Œæ—¶ï¼Œ`this`ä¸Šä¸‹æ–‡å’Œæ‰€æœ‰å‚æ•°éƒ½ä¼šåŸæ ·ä¼ é€’ç»™`callback`ã€‚
 *
 * @param options
 * An object to configure options.
 * ç”¨äºé…ç½®é€‰é¡¹çš„å¯¹è±¡ã€‚
 *
 * @return A new throttled function.
 */
declare function throttle<T extends (...args: any[]) => any>(delay: number, callback: T, options?: ThrottleOptions): FnNoReturn<T> & Cancel;
//#endregion
//#region src/guard/not-nullish.d.ts
/**
 * guard function that returns if val is not null or undefined
 *
 * å®ˆå«å‡½æ•°ï¼Œè¿”å› val ä¸ä¸º null æˆ– undefined
 *
 * @category Function
 * @example
 * ```ts
 * [1, '', false, null, undefined].filter(notNullish) // => [1, '', false]
 * ```
 */
declare function notNullish<T>(val: T | null | undefined): val is NonNullable<T>;
//#endregion
//#region src/guard/not-undefined.d.ts
/**
 * guard function that returns if val is not undefined
 *
 * å®ˆå«å‡½æ•°ï¼Œè¿”å› val ä¸ä¸º undefined
 *
 * @category Function
 * @example
 * ```ts
 * [1, '', false, undefined].filter(NotUndefined) // => [1, '', false]
 * ```
 */
declare function notUndefined(val: unknown): boolean;
//#endregion
//#region src/guard/to-string.d.ts
/**
 * Get the string representation of a value
 *
 * è·å–å€¼çš„å­—ç¬¦ä¸²è¡¨ç¤º
 *
 * @category Guard
 */
declare function toString(s: unknown): string;
//#endregion
//#region src/guard/to-truthy.d.ts
/**
 * guard function that returns if val is truthy
 *
 * å®ˆå«å‡½æ•°ï¼Œè¿”å› val æ˜¯å¦ä¸ºçœŸå€¼
 *
 * @category Function
 * @example
 * ```ts
 * [1, 2, 3, '', false, undefined].filter(toTruthy) // => [1, 2, 3]
 * ```
 */
declare function toTruthy(val: unknown): boolean;
//#endregion
//#region src/is.d.ts
declare function typeOf(s: unknown): string;
/**
 * Checks if a value is of a given type
 *
 * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºç»™å®šç±»å‹
 *
 * @category Common
 * @example
 * ```ts
 * isTypeof(null, 'null') // => true
 * isTypeof(undefined, 'undefined') // => true
 * isTypeof({}, 'object') // => true
 * ```
 */
declare function isTypeof(s: unknown, type: string): boolean;
/**
 * Checks if the input is defined
 * @category Predicate
 */
declare function isDef<T = any>(v?: T): v is T;
/**
 * Checks if the input is a primitive
 * @category Predicate
 */
declare function isPrimitive(v: unknown): v is null | undefined | boolean | number | string | symbol | bigint;
/**
 * Checks if the input is a boolean
 * @category Predicate
 */
declare function isBoolean(v: unknown): v is boolean;
/**
 * Checks if the input is a function.
 * @category Predicate
 */
declare function isFunction<T extends (...args: any[]) => any>(v: unknown): v is T;
/**
 * Checks if the input is a number
 * @category Predicate
 */
declare function isNumber(v: unknown): v is number;
/**
 * Checks if the input is a string
 * @category Predicate
 */
declare function isString(v: unknown): v is string;
/**
 * Checks if the input is a symbol
 * @category Predicate
 */
declare function isSymbol(v: unknown): v is symbol;
/**
 * Checks if the input is an object
 * @category Predicate
 */
declare function isPlainObject(v: unknown): v is Record<PropertyKey, unknown>;
/**
 * Checks if the input is an array
 * @category Predicate
 */
declare function isArray<T>(v: unknown): v is T[];
/**
 * Checks if the input is undefined
 *
 * @category Predicate
 */
declare function isUndefined(v: unknown): v is undefined;
/**
 * Checks if the input is null
 * @category Predicate
 */
declare function isNull(v: unknown): v is null;
/**
 * Checks if the input is a regexp
 * @category Predicate
 */
declare function isRegexp(v: unknown): v is RegExp;
/**
 * Checks if the input is a date
 * @category Predicate
 */
declare function isDate(v: unknown): v is Date;
/**
 * Check if an object has a property
 *
 * æ£€æŸ¥ä¸€ä¸ªå¯¹è±¡æ˜¯å¦æœ‰å±æ€§
 *
 * @category Predicate
 */
declare function isKeyof<T extends object>(obj: T, key: PropertyKey): key is keyof T;
/**
 * Checks if the input is an empty object
 * @category Predicate
 */
declare function isEmptyObject(v: unknown): boolean;
/**
 * Checks if the input is a blob
 * @category Predicate
 */
declare function isBlob(v: unknown): v is Blob;
/**
 * Checks if the input is a typed array
 * @category Predicate
 */
declare function isTypedArray(v: unknown): v is Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
/**
 * Checks if the input is a buffer
 *
 * @category Predicate
 */
declare function isBuffer(v: unknown): boolean;
/**
 * Checks if the input is a window
 * @category Predicate
 */
declare function isWindow(): boolean;
/**
 * Checks if the input is a browser
 * @category Predicate
 */
declare function isBrowser(): boolean;
/**
 * Checks if a value is a JSON object.
 * @category Predicate
 */
declare function isJSONObject(obj: unknown): obj is Record<string, any>;
/**
 * Checks if a given value is a valid JSON array.
 * @category Predicate
 */
declare function isJSONArray(value: unknown): value is any[];
/**
 * Checks if a given value is a valid JSON value.
 * @category Predicate
 */
declare function isJSONValue(value: unknown): value is Record<string, any> | any[] | string | number | boolean | null;
/**
 * Checks if the input is an integer
 *
 * æ£€æŸ¥è¾“å…¥æ˜¯å¦ä¸ºæ•´æ•°
 *
 * @category Predicate
 *
 * @example
 * ```ts
 * isInteger(1) // => true
 * isInteger(1.1) // => false
 * ```
 */
declare function isInteger<T>(v: T): v is Integer<T>;
/**
 * A strongly-typed version of `Number.isSafeInteger()`.
 *
 * `Number.isSafeInteger()` çš„å¼ºç±»å‹ç‰ˆæœ¬ã€‚
 *
 * @category Predicate
 *
 * @example
 * ```ts
 * isSafeInteger(1) // => true
 * isSafeInteger(1.1) // => false
 * ```
 */
declare function isSafeInteger<T>(v: T): v is Integer<T>;
/**
 * A strongly-typed version of `Number.isFinite()`.
 *
 * `Number.isFinite()` çš„å¼ºç±»å‹ç‰ˆæœ¬ã€‚
 *
 * @category Predicate
 *
 * @example
 * ```ts
 * isFinite(1) // => true
 * isFinite(Number.INFINITY) // => true
 * ```
 */
declare function isFinite<T extends number>(v: T): v is Finite<T>;
//#endregion
//#region src/math/clamp.d.ts
/**
 * Clamp a number between min and max
 *
 * è¿”å›ä¸€ä¸ªä»‹äºæœ€å°å€¼å’Œæœ€å¤§å€¼ä¹‹é—´çš„æ•°å­—
 *
 * @category Math
 */
declare function clamp(n: number, min: number, max: number): number;
//#endregion
//#region src/math/in-range.d.ts
/**
 * Check if a number is in range [0, max]
 *
 * æ£€æŸ¥ä¸€ä¸ªæ•°å­—æ˜¯å¦åœ¨ [0, max] èŒƒå›´å†…
 *
 * @category Math
 *
 * @param n - the number
 * @param max - the maximum number
 * @example
 * ```ts
 * inRange(5, 10) // => true
 * inRange(10, 5) // => false
 * ```
 */
declare function inRange(n: number, max: number): boolean;
/**
 * Check if a number is in range [min, max]
 *
 * æ£€æŸ¥ä¸€ä¸ªæ•°å­—æ˜¯å¦åœ¨ [min, max] èŒƒå›´å†…
 *
 * @category Math
 *
 * @param n - the number
 * @param min - the minimum number
 * @param max - the maximum number
 * @example
 * ```ts
 * inRange(5, 0, 10) // => true
 * inRange(10, 0, 5) // => false
 * ```
 */
declare function inRange(n: number, min: number, max: number): boolean;
//#endregion
//#region src/math/random.d.ts
/**
 * Random number
 *
 * è¿”å›ä¸€ä¸ªä»‹äº 0 å’Œ max ä¹‹é—´çš„éšæœºæ•°
 *
 * @category Math
 *
 * @param max - the maximum number. æœ€å¤§å€¼
 * @param float - (optional) if `true`, returns a floating-point number. æ˜¯å¦è¿”å›æµ®ç‚¹æ•°
 *
 * @example
 * ```ts
 * random(5) // => an integer between 0 and 5
 * random(5, true) // => a floating-point number between 0 and 5
 * ```
 */
declare function random(max: number, float?: boolean): number;
/**
 * Random number between min and max
 *
 * è¿”å›ä¸€ä¸ªä»‹äº min å’Œ max ä¹‹é—´çš„éšæœºæ•°
 *
 * @category Math
 *
 * @param min - the minimum number. æœ€å°å€¼
 * @param max - the maximum number. æœ€å¤§å€¼
 * @param float - (optional) if `true`, returns a floating-point number. æ˜¯å¦è¿”å›æµ®ç‚¹æ•°
 *
 * @example
 * ```ts
 * random(1, 5) // => an integer between 1 and 5
 * random(1, 5, true) // => a floating-point number between 1 and 5
 * ```
 */
declare function random(min: number, max: number, float?: boolean): number;
//#endregion
//#region src/object/clone.d.ts
/**
 * clone data
 *
 * å…‹éš†æ•°æ®
 *
 * @module Clone
 */
/**
 * simple clone, use JSON.parse and JSON.stringify
 *
 * ç®€å•çš„å…‹éš†,ä½¿ç”¨ JSON.parse å’Œ JSON.stringify
 *
 * @category Clone
 */
declare function simpleClone<T = any>(source: T): T;
/**
 * shallow clone, only clone the first level
 *
 * æµ…å…‹éš†,åªå…‹éš†ç¬¬ä¸€å±‚
 *
 * @category Clone
 */
declare function shallowClone<T = any>(source: T): T;
/**
 * Deep Clone.
 *
 * æ·±åº¦å…‹éš†
 *
 * @category Clone
 */
declare function deepClone<T = any>(source: T): T;
//#endregion
//#region src/object/deep-freeze.d.ts
/**
 * Freeze an object recursively and its properties
 *
 * é€’å½’å†»ç»“ä¸€ä¸ªå¯¹è±¡åŠå…¶å±æ€§
 *
 * @category Object
 */
declare function deepFreeze<T>(obj: T): T;
//#endregion
//#region src/object/deep-merge.d.ts
/**
 * Deep merge
 *
 * The first argument is the target object, the rest are the sources.
 * The target object will be mutated and returned.
 *
 * æ·±åº¦åˆå¹¶
 *
 * ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç›®æ ‡å¯¹è±¡ï¼Œå…¶ä½™çš„æ˜¯æºå¯¹è±¡ã€‚
 * ç›®æ ‡å¯¹è±¡å°†è¢«ä¿®æ”¹å¹¶è¿”å›ã€‚
 *
 * @category Object
 */
declare function deepMerge<T extends Record<PropertyKey, any>, S extends Record<PropertyKey, any> = T>(target: T, ...sources: S[]): DeepMerge<T, S>;
/**
 * Deep merge
 *
 * Differs from `deepMerge` in that it merges arrays instead of overriding them.
 *
 * The first argument is the target object, the rest are the sources.
 * The target object will be mutated and returned.
 *
 * æ·±åº¦åˆå¹¶
 *
 * ä¸ `deepMerge` ä¸åŒï¼Œå®ƒåˆå¹¶æ•°ç»„è€Œä¸æ˜¯è¦†ç›–å®ƒä»¬ã€‚
 *
 * ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç›®æ ‡å¯¹è±¡ï¼Œå…¶ä½™çš„æ˜¯æºã€‚
 * ç›®æ ‡å¯¹è±¡å°†è¢«ä¿®æ”¹å¹¶è¿”å›ã€‚
 *
 * @category Object
 */
declare function deepMergeWithArray<T extends Record<PropertyKey, any>, S extends Record<PropertyKey, any> = T>(target: T, ...sources: S[]): DeepMerge<T, S>;
type MergeInsertions<T> = T extends object ? { [K in keyof T]: MergeInsertions<T[K]> } : T;
/**
 * Deep merge
 */
type DeepMerge<F, S> = MergeInsertions<{ [K in keyof F | keyof S]: K extends keyof S & keyof F ? DeepMerge<F[K], S[K]> : K extends keyof S ? S[K] : K extends keyof F ? F[K] : never }>;
//#endregion
//#region src/object/entries.d.ts
/**
 * Strict typed `Object.entries`
 *
 * ä¸¥æ ¼ç±»å‹çš„ `Object.entries`
 *
 * @category Object
 * @example
 * ```ts
 * objectEntries({ a: 1, b: 2 }) // => [['a', 1], ['b', 2]]
 * ```
 */
declare function objectEntries<T extends object>(obj: T): Array<[keyof T, T[keyof T]]>;
//#endregion
//#region src/object/equal.d.ts
/**
 * Equal
 *
 * @module Equal
 */
/**
 * Deep equality two values, support array and object
 *
 * @category Equal
 */
declare function deepEqual(v1: any, v2: any): boolean;
//#endregion
//#region src/object/get.d.ts
/**
 * Retrieve a value from an object using dot path
 *
 * ä½¿ç”¨ dot path ä»ä¸€ä¸ªå¯¹è±¡ä¸­è·å–ä¸€ä¸ªå€¼
 *
 * @category Object
 * @example
 * ```ts
 * objectGet({ a: 1 }, 'a') // => 1
 * objectGet({ a: { b: 2 } }, 'a.b') // => 2
 * objectGet({ a: [{ b: 2 }] }, 'a[0].b') // => 2
 * ```
 */
declare function objectGet<T extends Record<PropertyKey, any>, P$1 extends ObjectKeyPaths<T>>(source: T, path: P$1): ObjectGet<T, P$1>;
type GenNode<K$1 extends string | number, IsRoot extends boolean> = IsRoot extends true ? `${K$1}` : `.${K$1}` | (K$1 extends number ? `[${K$1}]` | `.[${K$1}]` : never);
/**
 * Object key paths
 * @category Types
 */
type ObjectKeyPaths<T extends object, IsRoot extends boolean = true, K$1 extends keyof T = keyof T> = K$1 extends string | number ? GenNode<K$1, IsRoot> | (T[K$1] extends object ? `${GenNode<K$1, IsRoot>}${ObjectKeyPaths<T[K$1], false>}` : never) : never;
type KeysPaths<T extends string, O extends string = ''> = T extends `${infer R}['${infer K}']${infer Rest}` ? KeysPaths<Rest, `${O extends '' ? O : `${O}.`}${R}.${K}`> : T extends `${infer R}["${infer K}"]${infer Rest}` ? KeysPaths<Rest, `${O extends '' ? O : `${O}.`}${R}.${K}`> : T extends `${infer R}[${infer K}]${infer Rest}` ? KeysPaths<Rest, `${O extends '' ? O : `${O}.`}${R}.${K}`> : T extends '' ? O : `${O extends '' ? O : `${O}.`}${T}`;
/**
 * Get a value from an object
 * @category Types
 */
type ObjectGet<T extends Record<PropertyKey, any>, P$1 extends string> = KeysPaths<P$1> extends `${infer R}.${infer Rest}` ? ObjectGet<T[R], Rest> : T[P$1];
//#endregion
//#region src/object/has-own.d.ts
/**
 * Check if an object has a non-inherited property
 *
 * æ£€æŸ¥ä¸€ä¸ªå¯¹è±¡æ˜¯å¦å…·æœ‰éç»§æ‰¿å±æ€§
 *
 * @category Object
 */
declare function hasOwn<T>(obj: T, key: keyof any): key is keyof T;
//#endregion
//#region src/object/keys.d.ts
/**
 * Strict typed `Object.keys`
 *
 * ä¸¥æ ¼ç±»å‹çš„ `Object.keys`
 *
 * @category Object
 * @example
 * ```ts
 * objectKeys({ a: 1, b: 2 }) // => ['a', 'b']
 * ```
 */
declare function objectKeys<T extends object>(obj: T): Array<`${keyof T & (string | number | boolean | null | undefined)}`>;
//#endregion
//#region src/object/map.d.ts
/**
 * Map key/value pairs for an object, and construct a new one
 *
 * ä¸ºä¸€ä¸ªå¯¹è±¡æ˜ å°„é”®å€¼å¯¹ï¼Œå¹¶æ„é€ ä¸€ä¸ªæ–°å¯¹è±¡
 *
 * @category Object
 *
 * Transform:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => [k.toString().toUpperCase(), v.toString()])
 * // { A: '1', B: '2' }
 * ```
 *
 * Swap key/value:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => [v, k])
 * // { 1: 'a', 2: 'b' }
 * ```
 *
 * Filter keys:
 * @example
 * ```
 * objectMap({ a: 1, b: 2 }, (k, v) => k === 'a' ? undefined : [k, v])
 * // { b: 2 }
 * ```
 */
declare function objectMap<K$1 extends string, V, NK extends PropertyKey = K$1, NV = V>(obj: Record<K$1, V>, mapper: (key: K$1, value: V) => [NK, NV] | undefined): Record<NK, NV>;
//#endregion
//#region src/object/omit.d.ts
/**
 * Creates a new object with specified keys omitted.
 *
 * åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡ï¼Œçœç•¥æŒ‡å®šçš„é”®ã€‚
 *
 * @category Object
 * @example
 * ```ts
 * omit({ a: 1, b: 2 }, ['a']) // => { b: 2 }
 * ```
 */
declare function omit<T extends Record<PropertyKey, any>, K$1 extends keyof T = keyof T>(obj: T, keys: readonly K$1[]): Omit<T, K$1>;
//#endregion
//#region src/object/pick.d.ts
/**
 * Creates a new object composed of the picked object properties.
 *
 * åˆ›å»ºä¸€ä¸ªç”±æ‰€é€‰å¯¹è±¡å±æ€§ç»„æˆçš„æ–°å¯¹è±¡ã€‚
 *
 * @category Object
 * @example
 * ```ts
 * pick({ a: 1, b: 2 }, ['a']) // => { a: 1 }
 * ```
 */
declare function pick<T extends Record<PropertyKey, any>, K$1 extends keyof T = keyof T>(obj: T, keys: K$1[]): Pick<T, K$1>;
//#endregion
//#region src/promise/controlled.d.ts
/**
 * Return a Promise with `resolve` and `reject` methods
 *
 * è¿”å›ä¸€ä¸ª Promiseï¼Œå¸¦æœ‰ `resolve` å’Œ `reject` æ–¹æ³•
 *
 * @category Promise
 * @example
 * ```
 * const promise = createControlledPromise()
 *
 * await promise
 *
 * // in anther context:
 * promise.resolve(data)
 * ```
 */
declare function createControlledPromise<T>(): ControlledPromise<T>;
/**
 * Promise with `resolve` and `reject` methods of itself
 *
 * å¸¦æœ‰è‡ªèº«`resolve`å’Œ`reject`æ–¹æ³•çš„Promise
 *
 * @category Promise
 */
interface ControlledPromise<T = void> extends Promise<T> {
  resolve: (value: T | PromiseLike<T>) => void;
  reject: (reason?: any) => void;
}
//#endregion
//#region src/promise/limit-async.d.ts
/**
 * Wraps an async function to limit the number of concurrent executions.
 *
 * This function creates a wrapper around an async callback that ensures at most
 * `concurrency` number of executions can run simultaneously. Additional calls will
 * wait until a slot becomes available.
 *
 * å°†å¼‚æ­¥å‡½æ•°åŒ…è£…èµ·æ¥ä»¥é™åˆ¶å¹¶å‘æ‰§è¡Œçš„æ•°é‡ã€‚
 *
 * æ­¤å‡½æ•°åˆ›å»ºä¸€ä¸ªå¼‚æ­¥å›è°ƒçš„åŒ…è£…å™¨ï¼Œç¡®ä¿æœ€å¤šåªæœ‰`concurrency`ä¸ªæ‰§è¡Œå¯ä»¥åŒæ—¶è¿è¡Œã€‚
 * é¢å¤–çš„è°ƒç”¨å°†ç­‰å¾…ç›´åˆ°æœ‰å¯ç”¨çš„æ‰§è¡Œæ§½ä½ã€‚
 *
 * @category Array
 * @param callback - The async function to wrap. - è¦åŒ…è£…çš„å¼‚æ­¥å‡½æ•°
 * @param concurrency - The maximum number of concurrent executions. - æœ€å¤§å¹¶å‘æ•°
 * @returns The wrapped async function. - åŒ…è£…åçš„å¼‚æ­¥å‡½æ•°
 * @example
 * ```ts
 * const limitedFetch = limitAsync(async (url) => {
 *   return await fetch(url);
 * }, 3);
 *
 * // Only 3 fetches will run concurrently
 * const urls = ['url1', 'url2', 'url3', 'url4', 'url5'];
 * await Promise.all(urls.map(url => limitedFetch(url)));
 * ```
 */
declare function limitAsync<F extends (...args: any[]) => Promise<any>>(callback: F, concurrency: number): F;
//#endregion
//#region src/promise/lock.d.ts
/**
 * Create a promise task execution lock
 *
 * åˆ›å»ºä¸€ä¸ª promise ä»»åŠ¡æ‰§è¡Œé”
 *
 * @category Promise
 *
 * @example
 * ```
 * const lock = createPromiseLock()
 *
 * lock.run(async () => {
 *   await doSomething()
 * })
 *
 * // in anther context:
 * await lock.wait() // it will wait all tasking finished
 * ```
 */
declare function createPromiseLock(): {
  run: <T = void>(fn: () => Promise<T>) => Promise<T>;
  wait: () => Promise<void>;
  isWaiting: () => boolean;
  clear: () => void;
};
//#endregion
//#region src/promise/parallel.d.ts
/**
 * Executes an array of promises in parallel with a given concurrency. The function
 * returns a Promise that resolves with an array containing the resolved values of
 * each promise.
 * If any promise is rejected, the returned promise will be rejected.
 *
 * ä»¥æŒ‡å®šçš„å¹¶å‘æ•°å¹¶è¡Œæ‰§è¡Œä¸€ç»„ promiseã€‚è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª promiseï¼Œè¯¥ promise è§£æä¸ºä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«æ¯ä¸ª promise çš„è§£æå€¼ã€‚
 * ä»»æ„ä¸€ä¸ª promise æ‹’ç»ï¼Œè¿”å›çš„ promise å°†è¢«æ‹’ç»ã€‚
 *
 * @category Promise
 *
 * @param promises - the array of promises to execute
 * @param concurrency - (optional) the maximum number of promises to execute in parallel æœ€å¤§å¹¶å‘æ•°
 * @returns - a Promise that resolves with an array containing the resolved values of each promise
 *          - ä¸€ä¸ªPromiseï¼Œå®ƒè§£æä¸ºä¸€ä¸ªåŒ…å«æ¯ä¸ªpromiseè§£æå€¼çš„æ•°ç»„
 * @example
 * ```ts
 * const promises = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]
 * const result = await promiseParallel(promises, 2) // maximum concurrency of 2 - æœ€å¤§å¹¶å‘æ•°ä¸º2
 * console.log(result) // [1, 2, 3]
 * ```
 */
declare function promiseParallel(promises: (PromiseLike<any> | (() => PromiseLike<any>))[], concurrency?: number): Promise<any[]>;
/**
 * Creates a promise that is resolved with an array of promise settlement results,
 * in the same order as the input promises array.
 * The returned promise will be fulfilled when all of the input promises have settled,
 * either fulfilled or rejected.
 *
 * åˆ›å»ºä¸€ä¸ªä»¥è¾“å…¥ promise æ•°ç»„çš„ç»“æœæ•°ç»„è§£å†³çš„ promiseï¼Œ
 * æŒ‰ç…§è¾“å…¥ promise æ•°ç»„çš„ç›¸åŒé¡ºåºã€‚
 * å½“æ‰€æœ‰è¾“å…¥ promise éƒ½å·²è§£å†³æ—¶ï¼Œè¿”å›çš„ promiseå°†è¢«å®ç°ï¼Œ
 * è¦ä¹ˆå®ç°ï¼Œè¦ä¹ˆæ‹’ç»ã€‚
 *
 * @category Promise
 *
 * @param promises - the array of promises to execute
 * @param concurrency - (optional) the maximum number of promises to execute in parallel
 * @returns - a Promise that resolves with an array containing the resolved values of each promise
 *          - ä¸€ä¸ªPromiseï¼Œå®ƒè§£æä¸ºä¸€ä¸ªåŒ…å«æ¯ä¸ªpromiseè§£æçŠ¶æ€å’Œå€¼çš„æ•°ç»„
 * @example
 * ```ts
 * const promises = [Promise.resolve(1), Promise.resolve(2), Promise.reject('error')]
 * const result = await promiseParallelSettled(promises, 2) // maximum concurrency of 2 - æœ€å¤§å¹¶å‘æ•°ä¸º2
 * console.log(result) // [{ status: 'fulfilled', value: 1 }, { status: 'fulfilled', value: 2 }, { status: 'rejected', reason: 'error' }]
 * ```
 */
declare function promiseParallelSettled(promises: (PromiseLike<any> | (() => PromiseLike<any>))[], concurrency?: number): Promise<PromiseSettledResult<any>[]>;
//#endregion
//#region src/promise/retry.d.ts
/**
 * Retry a async function with a delay
 *
 * é‡è¯•å¼‚æ­¥å‡½æ•°å¹¶è®¾ç½®å»¶è¿Ÿ
 *
 * @category Promise
 * @param fn - the function to retry
 * @param options - the options
 * @param options.limit - the number of times to retry, default is 3 - é‡è¯•æ¬¡æ•°ï¼Œé»˜è®¤ 3
 * @param options.delay - the delay between retries, default is 0 - é‡è¯•é—´éš”ï¼Œé»˜è®¤ä¸º 0
 *
 * @example
 * ```ts
 * const result = await retry(async () => {
 *   return await fetch('https://example.com').then((res) => res.json())
 * }, {  limit: 3, delay: 1000 })
 * ```
 */
declare function retry<T>(fn: () => Promise<T>, {
  limit,
  delay
}?: {
  limit?: number;
  delay?: number;
}): Promise<T>;
//#endregion
//#region src/promise/semaphore.d.ts
/**
 * A counting semaphore for async functions that manages available permits.
 * Semaphores are mainly used to limit the number of concurrent async tasks.
 *
 * Each `acquire` operation takes a permit or waits until one is available.
 * Each `release` operation adds a permit, potentially allowing a waiting task to proceed.
 *
 * The semaphore ensures fairness by maintaining a FIFO (First In, First Out) order for acquirers.
 *
 * å¼‚æ­¥å‡½æ•°ä½¿ç”¨çš„è®¡æ•°ä¿¡å·é‡ï¼Œç®¡ç†å¯ç”¨è®¸å¯ã€‚
 * ä¿¡å·é‡ä¸»è¦ç”¨äºé™åˆ¶å¹¶å‘å¼‚æ­¥ä»»åŠ¡çš„æ•°é‡ã€‚
 *
 * æ¯æ¬¡ `acquire` æ“ä½œéƒ½ä¼šè·å–ä¸€ä¸ªè®¸å¯ï¼Œæˆ–è€…ç­‰å¾…ç›´åˆ°æœ‰ä¸€ä¸ªè®¸å¯å¯ç”¨ã€‚
 * æ¯æ¬¡ `release` æ“ä½œéƒ½ä¼šå¢åŠ ä¸€ä¸ªè®¸å¯ï¼Œå¯èƒ½å…è®¸ç­‰å¾…çš„ä»»åŠ¡ç»§ç»­æ‰§è¡Œã€‚
 *
 * ä¿¡å·é‡é€šè¿‡ç»´æŠ¤è·å–è€…çš„ FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰é¡ºåºæ¥ç¡®ä¿å…¬å¹³æ€§ã€‚
 *
 * @example
 * ```ts
 * const sema = new Semaphore(2);
 *
 * async function task() {
 *   await sema.acquire();
 *   try {
 *     // This code can only be executed by two tasks at the same time
 *   } finally {
 *     sema.release();
 *   }
 * }
 *
 * task();
 * task();
 * task(); // This task will wait until one of the previous tasks releases the semaphore.
 * ```
 */
declare class Semaphore {
  /**
   * The maximum number of concurrent operations allowed.
   *
   * å…è®¸çš„æœ€å¤§å¹¶å‘æ“ä½œæ•°ã€‚
   */
  capacity: number;
  /**
   * The number of available permits.
   *
   * å¯ç”¨è®¸å¯çš„æ•°é‡ã€‚
   */
  available: number;
  /**
   * The array of deferred tasks waiting for a permit.
   *
   * ç­‰å¾…è®¸å¯çš„å»¶æœŸä»»åŠ¡æ•°ç»„ã€‚
   */
  private deferredTasks;
  /**
   * Creates an instance of Semaphore.
   * @example
   * ```ts
   * const sema = new Semaphore(3); // Allows up to 3 concurrent operations.
   * ```
   */
  constructor(capacity: number);
  /**
   * Acquires a semaphore, blocking if necessary until one is available.
   *
   * è·å–ä¸€ä¸ªä¿¡å·é‡ï¼Œå¿…è¦æ—¶é˜»å¡ç›´åˆ°æœ‰ä¸€ä¸ªå¯ç”¨ã€‚
   *
   * @example
   * ```ts
   * const sema = new Semaphore(1);
   *
   * async function criticalSection() {
   *   await sema.acquire();
   *   try {
   *     // This code section cannot be executed simultaneously
   *   } finally {
   *     sema.release();
   *   }
   * }
   * ```
   */
  acquire(): Promise<void>;
  /**
   * Releases a semaphore, allowing one more operation to proceed.
   *
   * é‡Šæ”¾ä¸€ä¸ªä¿¡å·é‡ï¼Œå…è®¸å¦ä¸€ä¸ªæ“ä½œç»§ç»­è¿›è¡Œã€‚
   *
   * @example
   * ```ts
   * const sema = new Semaphore(1);
   *
   * async function task() {
   *   await sema.acquire();
   *   try {
   *     // This code can only be executed by two tasks at the same time
   *   } finally {
   *     sema.release(); // Allows another waiting task to proceed.
   *   }
   * }
   * ```
   */
  release(): void;
}
//#endregion
//#region src/promise/singleton.d.ts
/**
 * Wrap a promise as a singleton, returning the same promise on multiple calls.
 *
 * Through the `singleton.reset()` method, you can reset the currently expired promise and wait for it to close normally.
 *
 * å°†ä¸€ä¸ª promise åŒ…è£…ä¸ºå•ä¾‹ï¼Œåœ¨å¤šæ¬¡è°ƒç”¨æ—¶ï¼Œè¿”å›åŒä¸€ä¸ª promise
 *
 * é€šè¿‡ `singleton.reset` æ–¹æ³•å¯ä»¥é‡ç½®å½“å‰è¿‡æœŸçš„ promiseï¼Œå¹¶ç­‰å¾…å…¶æ­£å¸¸å…³é—­
 *
 * @category Promise
 *
 * @param fn - the function that returns the promise to wrap - è¦åŒ…è£…çš„ promise è¿”å›å‡½æ•°
 * @returns a function that returns the wrapped promise
 *          - è¿”å›åŒ…è£…åçš„ promise
 * @example
 * ```ts
 * let i = 1
 * const singleton = createSingletonPromise(() => Promise.resolve(i++))
 * const p1 = singleton()
 * const p2 = singleton()
 * console.log(p1 === p2) // true
 *
 * await p1() // will log: 2
 * await p2() // will log: 2
 * ```
 *
 * @example
 * ```ts
 * let i = 0
 * const singleton = createSingletonPromise(() => Promise.resolve(i++))
 *
 * await singleton() // will log: 1
 * await singleton.reset() // reset the promise, and await it to have proper shutdown
 * await singleton() // will log: 2
 * ```
 */
declare function createSingletonPromise<T>(fn: () => Promise<T>): SingletonPromise<T>;
interface SingletonPromise<T> {
  (): Promise<T>;
  /**
   * Reset current staled promise.
   * Await it to have proper shutdown.
   *
   * é‡ç½®å½“å‰è¿‡æœŸçš„ promiseã€‚
   * å¹¶ç­‰å¾…å…¶æ­£å¸¸å…³é—­ã€‚
   */
  reset: () => Promise<void>;
}
//#endregion
//#region src/promise/sleep.d.ts
interface SleepOptions {
  signal?: AbortSignal;
}
/**
 * Sleeps for the given number of milliseconds.
 *
 * ç»™å®šæ¯«ç§’æ•°ç¡çœ ã€‚
 *
 * @category Promise
 *
 * @param ms - the number of milliseconds to sleep. ç¡çœ çš„æ¯«ç§’æ•°
 * @param options - the options for the sleep. ç¡çœ çš„é…ç½®é¡¹
 * @param options.signal - the signal to abort the sleep. ç¡çœ çš„ä¸­æ­¢ä¿¡å·
 * @returns a promise
 *
 * @example
 * ```ts
 * console.log('Start');
 * await delay(1000); // Delays execution for 1 second
 * console.log('End');
 * ```
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * const { signal } = controller;
 *
 * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms
 * try {
 *   await delay(100, { signal });
 * } catch (error) {
 *   console.error(error); // Will log 'AbortError'
 * }
 * ```
 */
declare function sleep(ms: number, {
  signal
}?: SleepOptions): Promise<void>;
/**
 * Alias for `sleep`, Delays for the given number of milliseconds.
 *
 * `sleep` çš„åˆ«å, ç»™å®šæ¯«ç§’æ•°å»¶è¿Ÿã€‚
 *
 * also see {@link sleep}
 *
 * @category Promise
 */
declare const delay$1: typeof sleep;
//#endregion
//#region src/promise/timeout.d.ts
/**
 * Returns a promise that rejects with a `TimeoutError` after a specified delay.
 *
 * è¿”å›ä¸€ä¸ª promiseï¼Œè¯¥ promise åœ¨æŒ‡å®šçš„å»¶è¿Ÿæ—¶é—´åæ‹’ç»ï¼ŒæŠ›å‡ºä¸€ä¸ª `TimeoutError`ã€‚
 *
 * @category Promise
 * @param ms - the number of milliseconds to wait before rejecting the promise. è¶…æ—¶çš„æ¯«ç§’æ•°
 * @throws Throws a `TimeoutError` after the specified delay.
 * @example
 * ```ts
 * @example
 * ```
 * try {
 *   await timeout(1000); // Timeout exception after 1 second
 * } catch (error) {
 *   console.error(error); // Will log 'The operation was timed out'
 * }
 * ```
 */
declare function timeout(ms: number): Promise<never>;
/**
 * Executes an async function and enforces a timeout.
 *
 * æ‰§è¡Œå¼‚æ­¥å‡½æ•°, è¶…æ—¶åˆ™å¼ºåˆ¶æ‹’ç»
 *
 * @category Promise
 *
 * @param run - the async function to execute.
 * @param ms - the number of milliseconds to wait before rejecting the promise.
 * @returns A promise that resolves with the result of the async function, or rejects with a `TimeoutError` if the function does not resolve within the specified timeout. ä¸€ä¸ª promiseï¼Œå®ƒå°†è§£æä¸ºå¼‚æ­¥å‡½æ•°çš„ç»“æœï¼Œæˆ–è€…å¦‚æœåœ¨æŒ‡å®šè¶…æ—¶å†…å‡½æ•°æœªè§£æï¼Œåˆ™æ‹’ç»å¹¶æŠ›å‡º`TimeoutError`ã€‚
 * @example
 * ```ts
 * async function fetchData() {
 *   const response = await fetch('https://example.com/data');
 *   return response.json();
 * }
 *
 * try {
 *   const data = await withTimeout(fetchData, 1000);
 *   console.log(data); // Logs the fetched data if `fetchData` is resolved within 1 second.
 * } catch (error) {
 *   console.error(error); // Will log 'TimeoutError' if `fetchData` is not resolved within 1 second.
 * }
 * ```
 */
declare function withTimeout<T>(run: () => Promise<T>, ms: number): Promise<T>;
//#endregion
//#region src/string/camel-case.d.ts
/**
 * Convert string to camelCase
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºé©¼å³°å‘½åæ³•
 *
 * @category String
 *
 * @example
 * ```ts
 * camelCase('foo bar') // => fooBar
 * camelCase('foo-bar') // => fooBar
 * ```
 */
declare function camelCase(str: string): string;
//#endregion
//#region src/string/capitalize.d.ts
/**
 * First letter uppercase, other lowercase
 *
 * é¦–å­—æ¯å¤§å†™ï¼Œå…¶ä½™å°å†™
 *
 * @category String
 * @example
 * ```ts
 * capitalize('hello') // 'Hello'
 * capitalize('WORLD') // 'World'
 * ```
 */
declare function capitalize(s: string): string;
//#endregion
//#region src/string/constant-case.d.ts
/**
 * Converts a string to constant case
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¸¸é‡å‘½åæ³•
 *
 * @category String
 * @example
 * ```ts
 * constantCase('foo bar') // => FOO_BAR
 * constantCase('foo-bar') // => FOO_BAR
 * ```
 */
declare function constantCase(str: string): string;
//#endregion
//#region src/string/ensure-prefix.d.ts
/**
 * Ensure prefix, if str does not start with prefix, it will be added
 *
 * ç¡®ä¿å‰ç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥å‰ç¼€å¼€å¤´ï¼Œåˆ™å°†æ·»åŠ å‰ç¼€ã€‚
 *
 * @category String
 *
 * @param str - the string to check
 * @param prefix - the prefix to ensure
 *
 * @example
 * ```ts
 * ensurePrefix('example.com', 'http://') // => http://example.com
 * ensurePrefix('//example.com', '//') // => //example.com
 * ```
 */
declare function ensurePrefix(str: string, prefix: string): string;
//#endregion
//#region src/string/ensure-suffix.d.ts
/**
 * Ensure suffix, if str does not end with suffix, it will be added
 *
 * ç¡®ä¿åç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥è¯¥åç¼€ç»“å°¾ï¼Œåˆ™å°†æ·»åŠ è¯¥åç¼€ã€‚
 *
 * @category String
 *
 * @param str - the string to check
 * @param suffix - the suffix to ensure
 *
 * @example
 * ```ts
 * ensureSuffix('example.com', '.com') // => example.com
 * ensureSuffix('example', '.com') // => example.com
 * ```
 */
declare function ensureSuffix(str: string, suffix: string): string;
//#endregion
//#region src/string/escape.d.ts
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `str` to their corresponding HTML entities.
 *
 * å°†`str`ä¸­çš„å­—ç¬¦"&"ã€"<"ã€">"ã€'"'å’Œ"'"è½¬æ¢ä¸ºå¯¹åº”çš„HTMLå®ä½“ã€‚
 *
 * @category String
 * @example
 * ```ts
 * escape('<script>alert(1)</script>') // => &lt;script&gt;alert(1)&lt;/script&gt;
 * ```
 */
declare function escape(str: string): string;
/**
 * Escapes the RegExp special characters "^", "$", "\\", ".", "*", "+", "?", "(", ")", "[", "]", "{", "}", and "|" in `str`.
 *
 * è½¬ä¹‰`str`ä¸­çš„æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦"^"ã€"$"ã€"\\"ã€"."ã€"*"ã€"+"ã€"?"ã€"("ã€")"ã€"["ã€"]"ã€"{"ã€"}"ä»¥åŠ"|"ã€‚
 *
 * @category String
 * @example
 * ```ts
 * escapeRegExp('[link](https://sub.domain.com/)'); // '\[link\]\(https://sub\.domain\.com/\)'
 * ```
 */
declare function escapeRegExp(str: string): string;
/**
 * Converts the HTML entities `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `str` to their corresponding characters.
 * It is the inverse of `escape`.
 *
 * å°†`str`ä¸­çš„HTMLå®ä½“`&amp;`ã€`&lt;`ã€`&gt;`ã€`&quot;`å’Œ`&#39;`è½¬æ¢å›å¯¹åº”çš„å­—ç¬¦ã€‚
 * æ­¤æ“ä½œæ˜¯`escape`çš„é€†å‘è¿‡ç¨‹ã€‚
 *
 * @category String
 * @example
 * ```ts
 * unescape('&lt;script&gt;alert(1)&lt;/script&gt;') // => <script>alert(1)</script>
 * ```
 */
declare function unescape(str: string): string;
//#endregion
//#region src/string/kebab-case.d.ts
/**
 * Convert string to kebab-case
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºçŸ­æ¨ªçº¿å‘½åæ³•
 *
 * @category String
 *
 * @example
 * ```ts
 * kebabCase('a b c') // => a-b-c
 * kebabCase('orderBy') // => order-by
 * ```
 */
declare function kebabCase(str: string): string;
//#endregion
//#region src/string/lower-case.d.ts
/**
 * Convert string to lowercase
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°å†™
 *
 * @category String
 * @example
 * ```ts
 * lowerCase('Hello World') // => 'hello world'
 * lowerCase('HELLO WORLD') // => 'hello world'
 * lowerCase('order-by') // => 'order by'
 * ```
 */
declare function lowerCase(str: string): string;
//#endregion
//#region src/string/pascal-case.d.ts
/**
 * Converts a string to Pascal case
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¤§é©¼å³°å‘½åæ³•
 *
 * @category String
 * @example
 * ```ts
 * pascalCase('foo bar') // => FooBar
 * pascalCase('foo-bar') // => FooBar
 * ```
 */
declare function pascalCase(str: string): string;
//#endregion
//#region src/string/snake-case.d.ts
/**
 * Convert string to snake_case
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºè›‡å½¢å‘½åæ³•
 *
 * @category String
 * @example
 * ```ts
 * snakeCase('a b c') // => a_b_c
 * snakeCase('orderBy') // => order_by
 * ```
 */
declare function snakeCase(str: string): string;
//#endregion
//#region src/string/upper-case.d.ts
/**
 * Convert string to uppercase
 *
 * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¤§å†™
 *
 * @category String
 * @example
 * ```ts
 * upperCase('Hello World') // => 'HELLO WORLD'
 * upperCase('hello world') // => 'HELLO WORLD'
 * upperCase('order-by') // => 'ORDER BY'
 * ```
 */
declare function upperCase(str: string): string;
//#endregion
//#region src/string/words.d.ts
/**
 * This pattern matches sequences of characters in a string, considering the following cases:
 * - Sequences of two or more uppercase letters followed by an uppercase letter and lowercase letters or digits (for acronyms)
 * - Sequences of one uppercase letter optionally followed by lowercase letters and digits
 * - Single uppercase letters
 * - Sequences of digits
 * - Emojis and other Unicode characters
 *
 * The resulting match can be used to convert camelCase, snake_case, kebab-case,
 * and other mixed formats into a consistent format like snake case.
 * It also supports emojis and other Unicode characters.
 *
 * è¿™ä¸ªæ¨¡å¼åŒ¹é…å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦åºåˆ—ï¼Œè€ƒè™‘ä»¥ä¸‹æƒ…å†µ:
 * - ä¸¤ä¸ªæˆ–æ›´å¤šå¤§å†™å­—æ¯åè·Ÿç€å¤§å†™å­—æ¯å’Œå°å†™å­—æ¯æˆ–æ•°å­—çš„åºåˆ—ï¼ˆç”¨äºç¼©å†™ï¼‰
 * - ä¸€ä¸ªå¤§å†™å­—æ¯å¯é€‰åœ°åè·Ÿç€å°å†™å­—æ¯å’Œæ•°å­—çš„åºåˆ—
 * - å•ä¸ªå¤§å†™å­—æ¯
 * - æ•°å­—çš„åºåˆ—
 * - Emoji å’Œå…¶ä»– Unicode å­—ç¬¦
 *
 * åŒ¹é…ç»“æœå¯ç”¨äºå°†é©¼å³°å¼ã€è›‡å½¢ã€çŸ­æ¨ªçº¿å¼åŠå…¶ä»–æ··åˆæ ¼å¼è½¬æ¢ä¸ºç»Ÿä¸€çš„æ ¼å¼ï¼Œ
 * å¦‚è›‡å½¢å‘½åæ³•ã€‚åŒæ—¶æ”¯æŒè¡¨æƒ…ç¬¦å·åŠå…¶ä»– Unicode å­—ç¬¦ã€‚
 *
 * @category String
 *
 * @example
 * ```ts
 * const matched = 'caseCaseHTMLResponseğŸš€'.match(CASE_SPLIT_PATTERN)
 * // ['case', 'Case', 'HTML', 'Response', 'ğŸš€']
 * ```
 */
declare const CASE_SPLIT_PATTERN: RegExp;
/**
 * Split string into as words array
 *
 * å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå•è¯æ•°ç»„
 *
 * @category String
 *
 * @param str - the string to split è¦æ‹†åˆ†çš„å­—ç¬¦ä¸²
 * @returns an array of words å•è¯æ•°ç»„
 *
 * @example
 * ```ts
 * words('helloWorldğŸš€') // => ['hello', 'world', 'ğŸš€']
 * ```
 */
declare function words(str: string): string[];
//#endregion
//#region src/url/combine-urls.d.ts
/**
 * combines urls
 *
 * åˆå¹¶ urls
 *
 * @category URL
 * @example
 * ```ts
 * combineURLs('http://example.com', 'foo', 'bar') // => http://example.com/foo/bar
 * combineURLs('//example.com', '/foo') // => //example.com/foo
 * combineURLs('/foo', 'bar', 'index.html') // => /foo/bar/index.html
 * ```
 */
declare function combineURLs(baseUrl: string, ...urls: string[]): string;
//#endregion
//#region src/url/is-http.d.ts
/**
 * Check if url is http
 *
 * æ£€æŸ¥ url æ˜¯å¦ä¸º http
 *
 * @category URL
 */
declare function isHttp(url: string): boolean;
//#endregion
//#region src/url/is-url.d.ts
/**
 * Check if url is valid
 *
 * æ£€æŸ¥ url æ˜¯å¦æœ‰æ•ˆ
 *
 * @category URL
 */
declare function isUrl(url: string): boolean;
//#endregion
//#region src/url/parse-protocol.d.ts
/**
 * Parse protocol from url
 *
 * ä» url ä¸­è§£æåè®®
 *
 * @category URL
 * @example
 * ```ts
 * parseProtocol('http://example.com') // => http
 * parseProtocol('mailto:user@example.com') // => mailto
 * ```
 */
declare function parseProtocol(url: string): string;
//#endregion
//#region src/url/slash.d.ts
/**
 * Replace all backslashes with forward slashes
 *
 * å°†æ‰€æœ‰åæ–œæ æ›¿æ¢ä¸ºæ­£æ–œæ 
 *
 * @category URL
 * @example
 * ```ts
 * slash('foo\\bar') // => foo/bar
 * ```
 */
declare function slash(s: string): string;
/**
 * Ensure leading slash, if str does not start with slash, it will be added
 *
 * ç¡®ä¿å‰ç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥æ–œæ å¼€å¤´ï¼Œåˆ™å°†æ·»åŠ æ–œæ 
 *
 * @category URL
 * @example
 * ```ts
 * ensureLeadingSlash('foo/bar') // => /foo/bar
 * ```
 */
declare function ensureLeadingSlash(str: string): string;
/**
 * Ensure trailing slash, if str does not end with slash, it will be added
 *
 * ç¡®ä¿åç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ä»¥æ–œæ ç»“å°¾ï¼Œåˆ™å°†æ·»åŠ æ–œæ 
 *
 * @category URL
 * @example
 * ```ts
 * ensureTrailingSlash('/foo/bar') // => /foo/bar/
 * ```
 */
declare function ensureTrailingSlash(str: string): string;
/**
 * Remove leading slash, if str starts with slash, it will be removed
 *
 * åˆ é™¤æ–œæ†å‰ç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä»¥æ–œæ å¼€å¤´ï¼Œåˆ™å°†åˆ é™¤
 *
 * @category URL
 * @example
 * ```ts
 * removeLeadingSlash('/foo/bar') // => foo/bar
 * ```
 */
declare function removeLeadingSlash(str: string): string;
/**
 * Remove trailing slash, if str ends with slash, it will be removed
 *
 * åˆ é™¤æ–œæ†åç¼€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä»¥æ–œæ ç»“å°¾ï¼Œåˆ™å°†åˆ é™¤
 *
 * @category URL
 * @example
 * ```ts
 * removeTrailingSlash('/foo/bar/') // => /foo/bar
 * ```
 */
declare function removeTrailingSlash(str: string): string;
//#endregion
//#region src/util/assert.d.ts
/**
 * helpers
 *
 * @module Assert
 */
/**
 * Asserts that a condition is true
 *
 * @param condition the condition to assert
 * @param message the message to display if the condition is false
 *
 * @category Common
 */
declare function assert(condition: unknown, message?: string): asserts condition;
//#endregion
//#region src/util/attempt.d.ts
/**
 * Attempt to execute a function and return the result or error.
 * Returns a tuple where:
 * - On success: [null, Result] - First element is null, second is the result
 * - On error: [Error, null] - First element is the caught error, second is null
 *
 * **Only applicable to synchronous execution functions**
 *
 * å°è¯•æ‰§è¡Œå‡½æ•°å¹¶è¿”å›ç»“æœæˆ–é”™è¯¯ã€‚è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œå…¶ä¸­ï¼š
 * - æˆåŠŸæ—¶ï¼š[null, Result] - ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºnullï¼Œç¬¬äºŒä¸ªä¸ºç»“æœ
 * - é”™è¯¯æ—¶ï¼š[Error, null] - ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºæ•è·çš„é”™è¯¯ï¼Œç¬¬äºŒä¸ªä¸ºnull
 *
 * **ä»…é€‚ç”¨äºåŒæ­¥æ‰§è¡Œå‡½æ•°**
 *
 * @category Util
 *
 * @param func - The function to execute - è¦æ‰§è¡Œçš„å‡½æ•°
 * @param args - The arguments to pass to the function - è¦ä¼ é€’ç»™å‡½æ•°çš„å‚æ•°
 *
 * @example
 * ```ts
 * const [error, result] = attempt(() => 12) // [null, 12]
 * const [error, result] = attempt(() => { throw new Error('error') }) // [Error, null]
 * ```
 *
 * @example
 * ```ts
 * const add = (a, b) => a + b
 * const [error, result] = attempt(add, 1, 2) // [null, 3]
 * // or
 * const [error, result] = attempt(() => add(1, 2)) // [null, 3]
 * ```
 */
declare function attempt<T extends (...args: any[]) => any, E extends Error>(func: T, ...args: Parameters<T>): [null, ReturnType<T>] | [E, null];
//#endregion
//#region src/util/attempt-async.d.ts
/**
 * Attempt to execute a function and return the result or error.
 * Returns a Promise that resolves to a tuple where:
 * - On success: [null, Result] - First element is null, second is the result
 * - On error: [Error, null] - First element is the caught error, second is null
 *
 * **Only applicable to asynchronous execution functions**
 *
 * å°è¯•æ‰§è¡Œå‡½æ•°å¹¶è¿”å›ç»“æœæˆ–é”™è¯¯ã€‚è¿”å›ä¸€ä¸ªè§£æä¸ºå…ƒç»„çš„ Promiseï¼Œå…¶ä¸­ï¼š
 * - æˆåŠŸæ—¶ï¼š[null, Result] - ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºnullï¼Œç¬¬äºŒä¸ªä¸ºç»“æœ
 * - é”™è¯¯æ—¶ï¼š[Error, null] - ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºæ•è·çš„é”™è¯¯ï¼Œç¬¬äºŒä¸ªä¸ºnull
 *
 * **ä»…é€‚ç”¨äºå¼‚æ­¥æ‰§è¡Œå‡½æ•°**
 *
 * @category Util
 *
 * @param func - The asynchronous function to execute - è¦æ‰§è¡Œçš„å¼‚æ­¥å‡½æ•°
 * @param args - The arguments to pass to the function - è¦ä¼ é€’ç»™å‡½æ•°çš„å‚æ•°
 *
 * @example
 * ```ts
 * const [error, result] = await attempt(() => Promise.resolve(12)) // [null, 12]
 * const [error, result] = await attempt(() => { Promise.reject(new Error('error')) }) // [Error, null]
 * ```
 *
 * @example
 * ```ts
 * const add = (a, b) => Promise.resolve(a + b)
 * const [error, result] = await attempt(add, 1, 2) // [null, 3]
 * // or
 * const [error, result] = await attempt(async() => await add(1, 2)) // [null, 3]
 * ```
 */
declare function attemptAsync<T extends (...args: any[]) => Promise<any>, E extends Error>(func: T, ...args: Parameters<T>): Promise<[null, AsyncReturnType<T>] | [E, null]>;
//#endregion
export { Arrayable, AsyncFn, AsyncReturnType, Awaitable, CASE_SPLIT_PATTERN, Constructor, ControlledPromise, DebounceOptions, ElementOf, EventEmitter, EventListener, EventListenerList, EventListenerMap, EventType, EventWildcardListener, EventWildcardListenerList, Finite, Float, Fn, If, IfAny, IfNever, IfNotAnyOrNever, IfNull, IfUndefined, IfUnknown, Integer, IsAny, IsAnyOrNever, IsEqual, IsFloat, IsInteger, IsNever, IsNotFalse, IsNull, IsNullable, IsPrimitive, IsUndefined, IsUnion, IsUnknown, LiteralUnion, LooseRequired, Negative, NegativeFloat, NegativeInfinity, NegativeInteger, Not, Nullable, PositiveInfinity, Prettify, Primitive, Semaphore, SingletonPromise, SleepOptions, ThrottleOptions, UnionToIntersection, UnionToTuple, _Numeric, assert, attempt, attemptAsync, camelCase, capitalize, chunk, clamp, combineURLs, compose, constantCase, createControlledPromise, createEmitter, createPromiseLock, createSingletonPromise, debounce, deepClone, deepEqual, deepFreeze, deepMerge, deepMergeWithArray, delay$1 as delay, difference, differenceBy, ensureLeadingSlash, ensurePrefix, ensureSuffix, ensureTrailingSlash, escape, escapeRegExp, filterAsync, hasOwn, inRange, intersection, intersectionBy, invoke, isArray, isBlob, isBoolean, isBrowser, isBuffer, isDate, isDef, isEmptyObject, isFinite, isFunction, isHttp, isInteger, isJSONArray, isJSONObject, isJSONValue, isKeyof, isNull, isNumber, isPlainObject, isPrimitive, isRegexp, isSafeInteger, isSameDay, isString, isSymbol, isTypedArray, isTypeof, isUndefined, isUrl, isWindow, kebabCase, limitAsync, lowerCase, mapAsync, move, noop, notNullish, notUndefined, objectEntries, objectGet, objectKeys, objectMap, omit, once, orderBy, parseProtocol, pascalCase, pick, promiseParallel, promiseParallelSettled, random, range, remove, removeBy, removeLeadingSlash, removeTrailingSlash, retry, shallowClone, shuffle, simpleClone, slash, sleep, snakeCase, sortBy, throttle, timeout, timestamp, toArray, toString, toTruthy, typeOf, unescape, union, unionBy, uniq, uniqBy, uniqWith, upperCase, withTimeout, words };