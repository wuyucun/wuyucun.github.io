{"version":3,"file":"index.js","names":["parseImageSize","isNumber"],"sources":["../src/legacy.ts","../src/obsidian.ts","../src/plugin.ts"],"sourcesContent":["/**\n * Fork and edited from https://github.com/tatsy/markdown-it-imsize/blob/master/lib/index.js\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\n// Parse image size\n//\nconst parseNumber = (\n  str: string,\n  pos: number,\n  max: number,\n): { ok: boolean; pos: number; value: string } => {\n  let char: number;\n  const start = pos;\n  const result = {\n    ok: false,\n    pos: pos,\n    value: \"\",\n  };\n\n  char = str.charCodeAt(pos);\n\n  while ((pos < max && char >= 48 /* 0 */ && char <= 57) /* 9 */ || char === 37 /* % */)\n    char = str.charCodeAt(++pos);\n\n  result.ok = true;\n  result.pos = pos;\n  result.value = str.slice(start, pos);\n\n  return result;\n};\n\nconst parseImageSize = (\n  str: string,\n  pos: number,\n  max: number,\n): { pos: number; width: string; height: string } | null => {\n  if (str.charCodeAt(pos) !== 61 /* = */) return null;\n\n  pos++;\n\n  // size must follow = without any white spaces as follows\n  // (1) =300x200\n  // (2) =300x\n  // (3) =x200\n  const char = str.charCodeAt(pos);\n\n  if (char !== 120 /* x */ && (char < 48 /* 0 */ || char > 57) /* 9 */) return null;\n\n  // parse width\n  const width = parseNumber(str, pos, max);\n\n  pos = width.pos;\n\n  // next character must be 'x'\n  if (str.charCodeAt(pos++) !== 120 /* x */) return null;\n\n  // parse height\n  const height = parseNumber(str, pos, max);\n\n  pos = height.pos;\n\n  return {\n    pos,\n    width: width.value,\n    height: height.value,\n  };\n};\n\n// oxlint-disable-next-line max-lines-per-function\nconst legacyImgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charCodeAt(state.pos) !== 33 /* ! */ ||\n    state.src.charCodeAt(state.pos + 1) !== 91 /* [ */\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  let pos = labelEnd + 1;\n  let char: number;\n\n  let href = \"\";\n  let title = \"\";\n  let width = \"\";\n  let height = \"\";\n\n  if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n\n      pos++;\n    }\n\n    // minimal 5 => [link]( a =1x)\n    if (pos + 5 > max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    let skipSpaces = false;\n\n    if (start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        if (!isSpace(state.src.charCodeAt(pos))) {\n          skipSpaces = true;\n          break;\n        }\n      }\n\n      if (!skipSpaces || pos + 3 > max) return false;\n    } else {\n      title = \"\";\n    }\n\n    const sizeInfo = parseImageSize(state.src, pos, state.posMax);\n\n    if (sizeInfo) {\n      ({ width, height, pos } = sizeInfo);\n\n      // [link](  <href>  \"title\" =WxH  )\n      //                              ^^ skipping these spaces\n      for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let label = \"\";\n\n    //\n    // Link reference\n    //\n    if (env.references === undefined) return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      char = state.src.charCodeAt(pos);\n      if (char !== 32 /* space */ && char !== 9 /* \\t */) break;\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) label = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) label = state.src.slice(labelStart, labelEnd);\n\n    const ref = env.references[state.md.utils.normalizeReference(label)];\n\n    // oxlint-disable-next-line typescript/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const content = state.src.slice(labelStart, labelEnd);\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(content, state.md, state.env, tokens);\n\n    const token = state.push(\"image\", \"img\", 0);\n\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n\n    if (width) attrs.push([\"width\", width]);\n\n    if (height) attrs.push([\"height\", height]);\n\n    token.attrs = attrs;\n\n    token.children = tokens;\n    token.content = content;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\n/**\n * @deprecated Recommended to use `imgSize` instead.\n *\n * @param md Markdown-it instance\n */\nexport const legacyImgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"emphasis\", \"image\", legacyImgSizeRule);\n};\n","import type { PluginSimple } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\nconst isNumber = (charCode: number): boolean => charCode >= 48 /* 0 */ && charCode <= 57; /* 9 */\n\n/**\n * Parse image size information from label text in Obsidian format\n * Format: `alt | width x height`\n *\n * @param label - image label text\n * @returns parsed size info or null if not valid\n */\nconst parseObsidianImageSize = (\n  label: string,\n): {\n  label: string;\n  width: string | null;\n  height: string | null;\n} | null => {\n  const max = label.length;\n  let pos = label.lastIndexOf(\"|\");\n\n  if (pos === -1) return null;\n\n  // Get original label part before the pipe\n  const origLabel = label.slice(0, pos++).trimEnd();\n\n  // Skip spaces after pipe\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) break;\n\n    pos++;\n  }\n\n  if (pos === max) return null;\n\n  const widthStart = pos;\n\n  while (pos < max && isNumber(label.charCodeAt(pos))) pos++;\n\n  if (pos === widthStart || pos === max) return null;\n\n  const width = label.slice(widthStart, pos);\n\n  // Skip spaces after width\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) break;\n\n    pos++;\n  }\n\n  // Check for 'x' character - 只接受小写 x\n  if (pos === max || label.charCodeAt(pos++) !== 120 /* x */) return null;\n\n  // Skip spaces after 'x'\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) break;\n\n    pos++;\n  }\n\n  const heightStart = pos;\n\n  while (pos < max && isNumber(label.charCodeAt(pos))) pos++;\n\n  if (pos === heightStart) return null;\n\n  // 验证宽度是有效的数字序列\n  const height = label.slice(heightStart, pos);\n  const widthNum = Number(width);\n  const heightNum = Number(height);\n\n  if (!widthNum && !heightNum) return null;\n\n  while (pos < max) if (!isSpace(label.charCodeAt(pos++))) return null;\n\n  return {\n    label: origLabel,\n    width: widthNum ? width : null,\n    height: heightNum ? height : null,\n  };\n};\n\nexport const obsidianImgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charCodeAt(state.pos) !== 33 /* ! */ ||\n    state.src.charCodeAt(state.pos + 1) !== 91 /* [ */\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  const rawLabel = state.src.slice(labelStart, labelEnd);\n\n  // check if label has img size\n  const sizeInfo = parseObsidianImageSize(rawLabel);\n\n  if (!sizeInfo) return false;\n\n  const { label, width, height } = sizeInfo;\n\n  let pos = labelEnd + 1;\n  let href = \"\";\n  let title = \"\";\n\n  if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n\n      pos++;\n    }\n\n    if (pos === max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n    } else {\n      title = \"\";\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let referenceLabel = \"\";\n\n    //\n    // Link reference\n    //\n    if (env.references === undefined) return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n\n    if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) referenceLabel = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!referenceLabel) referenceLabel = label;\n\n    const ref = env.references[state.md.utils.normalizeReference(referenceLabel)];\n\n    // oxlint-disable-next-line typescript/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const token = state.push(\"image\", \"img\", 0);\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n\n    if (width) attrs.push([\"width\", width]);\n\n    if (height) attrs.push([\"height\", height]);\n\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(label, state.md, state.env, tokens);\n\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = label;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const obsidianImgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"image\", \"obsidian-img-size\", obsidianImgSizeRule);\n};\n","import type { PluginSimple } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\nconst isNumber = (charCode: number): boolean => charCode >= 48 /* 0 */ && charCode <= 57; /* 9 */\n\n/**\n * Parse image size information from label text\n * Format: `alt =width x height`\n *\n * @param label - label text to parse\n * @returns parsed size info or null if not found\n */\nconst parseImageSize = (\n  label: string,\n): { label: string; width: string | null; height: string | null } | null => {\n  const max = label.length;\n  let pos = label.lastIndexOf(\"=\");\n\n  if (pos === -1 || pos + 3 > max) return null;\n\n  if (pos !== 0 && !isSpace(label.charCodeAt(pos - 1))) return null;\n\n  const origLabel = label.slice(0, pos++).trimEnd();\n\n  let width: string | null = null;\n  let height: string | null = null;\n\n  if (isNumber(label.charCodeAt(pos))) {\n    const startPos = pos;\n\n    while (pos < max && isNumber(label.charCodeAt(pos))) pos++;\n\n    width = label.slice(startPos, pos);\n\n    if (label.charCodeAt(pos++) !== 120 /* x */) return null;\n  } else if (label.charCodeAt(pos++) === 120 /* x */) {\n    // no width info\n  } else {\n    return null;\n  }\n\n  if (pos < max) {\n    const startPos = pos;\n\n    while (pos < max && isNumber(label.charCodeAt(pos))) pos++;\n\n    if (pos > startPos) height = label.slice(startPos, pos);\n  }\n\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) return null;\n\n    pos++;\n  }\n\n  return {\n    label: origLabel,\n    width,\n    height,\n  };\n};\n\nexport const imgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charCodeAt(state.pos) !== 33 /* ! */ ||\n    state.src.charCodeAt(state.pos + 1) !== 91 /* [ */\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  const rawLabel = state.src.slice(labelStart, labelEnd);\n\n  // check if label has img size\n  const sizeInfo = parseImageSize(rawLabel);\n\n  if (!sizeInfo) return false;\n\n  const { label, width, height } = sizeInfo;\n\n  let pos = labelEnd + 1;\n  let href = \"\";\n  let title = \"\";\n\n  if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n\n      pos++;\n    }\n\n    if (pos >= max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n    } else {\n      title = \"\";\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let referenceLabel = \"\";\n\n    //\n    // Link reference\n    //\n    if (env.references === undefined) return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) if (!isSpace(state.src.charCodeAt(pos))) break;\n\n    if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) referenceLabel = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!referenceLabel) referenceLabel = label;\n\n    const ref = env.references[state.md.utils.normalizeReference(referenceLabel)];\n\n    // oxlint-disable-next-line typescript/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const token = state.push(\"image\", \"img\", 0);\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n\n    if (width) attrs.push([\"width\", width]);\n\n    if (height) attrs.push([\"height\", height]);\n\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(label, state.md, state.env, tokens);\n\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = label;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const imgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"image\", \"img-size\", imgSizeRule);\n};\n"],"mappings":"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"}