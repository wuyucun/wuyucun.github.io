{"version":3,"file":"index.js","names":[],"sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-container/blob/master/index.mjs\n */\n\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { MarkdownItContainerOptions } from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\n\n// oxlint-disable-next-line max-lines-per-function\nexport const container: PluginWithOptions<MarkdownItContainerOptions> = (md, options) => {\n  if (typeof options !== \"object\" || !options.name)\n    throw new Error(\"[@mdit/plugin-container]: 'name' option is required.\");\n\n  const {\n    name,\n    marker = \":\",\n    validate = (params: string): boolean => params.trim().split(\" \", 2)[0] === name,\n    openRender = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      slf: Renderer,\n    ): string => {\n      // add a class to the opening tag\n      tokens[index].attrJoin(\"class\", name);\n\n      return slf.renderToken(tokens, index, options);\n    },\n    closeRender = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      slf: Renderer,\n    ): string => slf.renderToken(tokens, index, options),\n  } = options;\n\n  const markerStart = marker[0];\n  const markerLength = marker.length;\n\n  const container: RuleBlock = (state, startLine, endLine, silent) => {\n    const currentLineStart = state.bMarks[startLine] + state.tShift[startLine];\n    const currentLineMax = state.eMarks[startLine];\n    const currentLineIndent = state.sCount[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (markerStart !== state.src[currentLineStart]) return false;\n\n    let pos = currentLineStart + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= currentLineMax) {\n      if (marker[(pos - currentLineStart) % markerLength] !== state.src[pos]) break;\n\n      pos++;\n    }\n\n    const markerCount = Math.floor((pos - currentLineStart) / markerLength);\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    pos -= (pos - currentLineStart) % markerLength;\n\n    const markup = marker.repeat(markerCount);\n    const params = state.src.slice(pos, currentLineMax);\n\n    if (!validate(params, markup)) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (nextLineStart < nextLineMax && state.sCount[nextLine] < currentLineIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n      }\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === currentLineIndent &&\n        // match start\n        markerStart === state.src[nextLineStart]\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (marker[(pos - nextLineStart) % markerLength] !== state.src[pos]) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (Math.floor((pos - nextLineStart) / markerLength) >= markerCount) {\n          // make sure tail has spaces only\n          pos -= (pos - nextLineStart) % markerLength;\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error: We are creating a new type called \"container\"\n    state.parentType = \"container\";\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    // this will update the block indent\n    state.blkIndent = currentLineIndent;\n\n    const openToken = state.push(`container_${name}_open`, \"div\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = params;\n    openToken.map = [startLine, nextLine];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const closeToken = state.push(`container_${name}_close`, \"div\", -1);\n\n    closeToken.markup = markup;\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", `container_${name}`, container, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n  md.renderer.rules[`container_${name}_open`] = openRender;\n  md.renderer.rules[`container_${name}_close`] = closeRender;\n};\n"],"mappings":"AAWA,MAGa,GAA4D,EAAI,IAAY,CACvF,GAAI,OAAO,GAAY,UAAY,CAAC,EAAQ,KAC1C,MAAU,MAAM,uDAAuD,CAEzE,GAAM,CACJ,OACA,SAAS,IACT,WAAY,GAA4B,EAAO,MAAM,CAAC,MAAM,IAAK,EAAE,CAAC,KAAO,EAC3E,cACE,EACA,EACA,EACA,EACA,KAGA,EAAO,GAAO,SAAS,QAAS,EAAK,CAE9B,EAAI,YAAY,EAAQ,EAAO,EAAQ,EAEhD,eACE,EACA,EACA,EACA,EACA,IACW,EAAI,YAAY,EAAQ,EAAO,EAAQ,EAClD,EAEE,EAAc,EAAO,GACrB,EAAe,EAAO,OAqH5B,EAAG,MAAM,MAAM,OAAO,QAAS,aAAa,KAnHd,EAAO,EAAW,EAAS,IAAW,CAClE,IAAM,EAAmB,EAAM,OAAO,GAAa,EAAM,OAAO,GAC1D,EAAiB,EAAM,OAAO,GAC9B,EAAoB,EAAM,OAAO,GAKvC,GAAI,IAAgB,EAAM,IAAI,GAAmB,MAAO,GAExD,IAAI,EAAM,EAAmB,EAG7B,KAAO,GAAO,GACR,GAAQ,EAAM,GAAoB,KAAkB,EAAM,IAAI,IAElE,IAGF,IAAM,EAAc,KAAK,OAAO,EAAM,GAAoB,EAAa,CAEvE,GAAI,EAAc,EAAgB,MAAO,GAEzC,IAAQ,EAAM,GAAoB,EAElC,IAAM,EAAS,EAAO,OAAO,EAAY,CACnC,EAAS,EAAM,IAAI,MAAM,EAAK,EAAe,CAEnD,GAAI,CAAC,EAAS,EAAQ,EAAO,CAAE,MAAO,GAGtC,GAAI,EAAQ,MAAO,GAEnB,IAAI,EAAW,EAAY,EACvB,EAAa,GAGjB,KAKE,EAAW,EACX,IACA,CACA,IAAM,EAAgB,EAAM,OAAO,GAAY,EAAM,OAAO,GACtD,EAAc,EAAM,OAAO,GAEjC,GAAI,EAAgB,GAAe,EAAM,OAAO,GAAY,EAI1D,MAGF,GAEE,EAAM,OAAO,KAAc,GAE3B,IAAgB,EAAM,IAAI,GAC1B,CAEA,IAAK,EAAM,EAAgB,EAAG,GAAO,GAC/B,GAAQ,EAAM,GAAiB,KAAkB,EAAM,IAAI,GADf,KAIlD,GAAI,KAAK,OAAO,EAAM,GAAiB,EAAa,EAAI,IAEtD,IAAQ,EAAM,GAAiB,EAC/B,EAAM,EAAM,WAAW,EAAI,CAEvB,GAAO,GAAa,CAEtB,EAAa,GACb,QAMR,IAAM,EAAY,EAAM,WAClB,EAAa,EAAM,QACnB,EAAe,EAAM,UAG3B,EAAM,WAAa,YAGnB,EAAM,QAAU,EAGhB,EAAM,UAAY,EAElB,IAAM,EAAY,EAAM,KAAK,aAAa,EAAK,OAAQ,MAAO,EAAE,CAEhE,EAAU,OAAS,EACnB,EAAU,MAAQ,GAClB,EAAU,KAAO,EACjB,EAAU,IAAM,CAAC,EAAW,EAAS,CAErC,EAAM,GAAG,MAAM,SAAS,EAAO,EAAY,EAAG,EAAS,CAEvD,IAAM,EAAa,EAAM,KAAK,aAAa,EAAK,QAAS,MAAO,GAAG,CAUnE,MARA,GAAW,OAAS,EACpB,EAAW,MAAQ,GAEnB,EAAM,WAAa,EACnB,EAAM,QAAU,EAChB,EAAM,UAAY,EAClB,EAAM,KAAO,GAAY,EAAa,EAAI,GAEnC,IAGsD,CAC7D,IAAK,CAAC,YAAa,YAAa,aAAc,OAAO,CACtD,CAAC,CACF,EAAG,SAAS,MAAM,aAAa,EAAK,QAAU,EAC9C,EAAG,SAAS,MAAM,aAAa,EAAK,SAAW"}