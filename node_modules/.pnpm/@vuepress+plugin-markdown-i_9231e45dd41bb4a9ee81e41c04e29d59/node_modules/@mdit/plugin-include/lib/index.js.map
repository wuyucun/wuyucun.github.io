{"version":3,"file":"index.js","names":[],"sources":["../src/plugin.ts"],"sourcesContent":["import fs from \"node:fs\";\n\nimport { NEWLINE_RE, dedent } from \"@mdit/helper\";\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleCore } from \"markdown-it/lib/parser_core.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\nimport path from \"upath\";\n\nimport type { MarkdownItIncludeOptions } from \"./options.js\";\nimport type { IncludeEnv } from \"./types.js\";\n\ninterface ImportFileLineInfo {\n  filePath: string;\n  lineStart?: number | undefined;\n  lineEnd?: number | undefined;\n}\n\ninterface ImportFileRegionInfo {\n  filePath: string;\n  region: string;\n}\n\ntype ImportFileInfo = ImportFileLineInfo | ImportFileRegionInfo;\n\ninterface IncludeInfo {\n  cwd: string | null;\n  includedFiles: string[];\n  resolvedPath?: boolean;\n}\n\nconst REGIONS_RE = [\n  /^\\/\\/ ?#?((?:end)?region) ([\\w*-]+)$/, // javascript, typescript, java\n  /^\\/\\* ?#((?:end)?region) ([\\w*-]+) ?\\*\\/$/, // css, less, scss\n  /^#pragma ((?:end)?region) ([\\w*-]+)$/, // C, C++\n  /^<!-- #?((?:end)?region) ([\\w*-]+) -->$/, // HTML, markdown\n  /^#((?:End )Region) ([\\w*-]+)$/, // Visual Basic\n  /^::#((?:end)region) ([\\w*-]+)$/, // Bat\n  /^# ?((?:end)?region) ([\\w*-]+)$/, // C#, PHP, Powershell, Python, perl & misc\n];\n\n// regexp to match the import syntax\nconst INCLUDE_COMMENT_RE =\n  /^( *)<!-{2,}\\s*@include:\\s*([^<>|:\"*?]+(?:\\.[a-z0-9]+))(?:#([\\w-]+))?(?:\\{(\\d+)?-(\\d+)?\\})?\\s*-{2,}>\\s*$/gm;\nconst INCLUDE_RE =\n  /^( *)@include:\\s*([^<>|:\"*?]+(?:\\.[a-z0-9]+))(?:#([\\w-]+))?(?:\\{(\\d+)?-(\\d+)?\\})?\\s*$/gm;\n\nconst testLine = (line: string, regexp: RegExp, regionName: string, end = false): boolean => {\n  const [full, tag, name] = regexp.exec(line.trim()) ?? [];\n\n  return Boolean(\n    full && tag && name === regionName && tag.match(end ? /^[Ee]nd ?[rR]egion$/ : /^[rR]egion$/),\n  );\n};\n\nconst findRegion = (\n  lines: string[],\n  regionName: string,\n): { lineStart: number; lineEnd: number } | null => {\n  let regexp = null;\n  let lineStart = -1;\n\n  const lineEnd = lines.length;\n\n  for (let lineIndex = 0; lineIndex < lineEnd; lineIndex++) {\n    const line = lines[lineIndex];\n\n    if (regexp === null) {\n      for (let i = 0; i < REGIONS_RE.length; i++) {\n        const reg = REGIONS_RE[i];\n\n        if (testLine(line, reg, regionName)) {\n          lineStart = lineIndex + 1;\n          regexp = reg;\n          break;\n        }\n      }\n    } else if (testLine(line, regexp, regionName, true)) {\n      return { lineStart, lineEnd: lineIndex };\n    }\n  }\n\n  return null;\n};\n\nexport const handleInclude = (\n  info: ImportFileInfo,\n  { cwd, includedFiles, resolvedPath }: IncludeInfo,\n): string => {\n  const { filePath } = info;\n  let realPath = filePath;\n\n  if (!path.isAbsolute(filePath)) {\n    // if the importPath is relative path, we need to resolve it\n    // according to the markdown filePath\n    if (!cwd) {\n      // oxlint-disable-next-line no-console\n      console.error(`[@mdit/plugin-include]: Error when resolving path: ${filePath}`);\n\n      return \"\\nError when resolving path\\n\";\n    }\n\n    realPath = path.resolve(cwd, filePath);\n  }\n\n  includedFiles.push(realPath);\n\n  // check file existence\n  if (!fs.existsSync(realPath)) {\n    // oxlint-disable-next-line no-console\n    console.error(`[@mdit/plugin-include]: ${realPath} not found`);\n\n    return \"\\nFile not found\\n\";\n  }\n\n  // read file content\n  const fileContent = fs.readFileSync(realPath).toString();\n\n  const lines = fileContent.replace(NEWLINE_RE, \"\\n\").split(\"\\n\");\n  let results: string[] = [];\n\n  // is region\n  if (\"region\" in info) {\n    const region = findRegion(lines, info.region);\n\n    if (region) results = lines.slice(region.lineStart, region.lineEnd);\n  }\n  // is file\n  else {\n    const { lineStart, lineEnd } = info;\n\n    if (lineStart) {\n      results = lines.slice(lineStart - 1, lineEnd);\n    } else if (lines[0] === \"---\") {\n      const endLineIndex = lines.findIndex((line, index) => index !== 0 && line === \"---\");\n\n      results = lines.slice(Math.max(endLineIndex + 1, 1), lineEnd);\n    } else {\n      results = lines.slice(0, lineEnd);\n    }\n  }\n\n  if (resolvedPath && realPath.endsWith(\".md\")) {\n    const dirName = path.dirname(realPath);\n\n    results.unshift(`<!-- #include-env-start: ${dirName} -->`);\n    results.push(\"<!-- #include-env-end -->\");\n  }\n\n  return dedent(results.join(\"\\n\").replace(/\\n?$/, \"\\n\"));\n};\n\nexport const resolveInclude = (\n  content: string,\n  options: Required<MarkdownItIncludeOptions>,\n  { cwd, includedFiles }: IncludeInfo,\n): string =>\n  content.replace(\n    options.useComment ? INCLUDE_COMMENT_RE : INCLUDE_RE,\n    // oxlint-disable-next-line max-params\n    (\n      _,\n      indent: string,\n      includePath: string,\n      region?: string,\n      lineStart?: string,\n      lineEnd?: string,\n    ) => {\n      const actualPath = options.resolvePath(includePath, cwd);\n      const resolvedPath = options.resolveImagePath || options.resolveLinkPath;\n\n      const content = handleInclude(\n        Object.assign(\n          { filePath: actualPath },\n          region\n            ? { region }\n            : {\n                lineStart: lineStart ? Number(lineStart) : undefined,\n                lineEnd: lineEnd ? Number(lineEnd) : undefined,\n              },\n        ),\n        { cwd, includedFiles, resolvedPath },\n      );\n\n      return (\n        options.deep && actualPath.endsWith(\".md\")\n          ? resolveInclude(content, options, {\n              cwd: path.isAbsolute(actualPath)\n                ? path.dirname(actualPath)\n                : cwd\n                  ? path.resolve(cwd, path.dirname(actualPath))\n                  : null,\n              includedFiles,\n            })\n          : content\n      )\n        .split(\"\\n\")\n        .map((line) => indent + line)\n        .join(\"\\n\");\n    },\n  );\n\nconst SYNTAX_PUSH_RE = /^<!-- #include-env-start: ([^)]*?) -->$/;\n\nconst includePushRule: RuleBlock = (state, startLine, _, silent): boolean => {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  const max = state.eMarks[startLine];\n\n  const content = state.src.slice(start, max);\n\n  if (content.startsWith(\"<!-- #include-env-start: \")) {\n    // check if itâ€™s matched the syntax\n    const match = SYNTAX_PUSH_RE.exec(content);\n\n    if (match) {\n      if (silent) return true;\n\n      const [, includePath] = match;\n\n      state.line = startLine + 1;\n      const token = state.push(\"include_start\", \"\", 0);\n\n      token.map = [startLine, state.line];\n      token.info = includePath;\n      token.markup = \"include_start\";\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst includePopRule: RuleBlock = (state, startLine, _endLine, silent): boolean => {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  const max = state.eMarks[startLine];\n\n  if (state.src.slice(start, max) === \"<!-- #include-env-end -->\") {\n    if (silent) return true;\n\n    state.line = startLine + 1;\n\n    const token = state.push(\"include_end\", \"\", 0);\n\n    token.map = [startLine, state.line];\n    token.markup = \"include_end\";\n\n    return true;\n  }\n\n  return false;\n};\n\nconst resolveRelatedLink = (\n  attr: string,\n  token: Token,\n  filePath: string,\n  includedPaths?: string[],\n): void => {\n  const attrIndex = token.attrIndex(attr);\n  const url = token.attrs?.[attrIndex][1];\n\n  if (url?.[0] === \".\" && Array.isArray(includedPaths)) {\n    const { length } = includedPaths;\n\n    if (length) {\n      const includeDir = path.relative(path.dirname(filePath), includedPaths[length - 1]);\n\n      const resolvedPath = path.join(includeDir, url);\n\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      token.attrs![attrIndex][1] = resolvedPath[0] === \".\" ? resolvedPath : `./${resolvedPath}`;\n    }\n  }\n};\n\nexport const include: PluginWithOptions<MarkdownItIncludeOptions> = (md, options): void => {\n  const {\n    currentPath,\n    resolvePath = (path: string): string => path,\n    deep = false,\n    resolveLinkPath = true,\n    resolveImagePath = true,\n    useComment = true,\n  } = options ?? {};\n\n  if (typeof currentPath !== \"function\")\n    throw new TypeError('[@mdit/plugin-include]: \"currentPath\" is required');\n\n  const includeRule: RuleCore = (state): void => {\n    const env = state.env as IncludeEnv;\n    const includedFiles = (env.includedFiles ??= []);\n    const filePath = currentPath(env);\n\n    state.src = resolveInclude(\n      state.src,\n      {\n        currentPath,\n        resolvePath,\n        deep,\n        resolveLinkPath,\n        resolveImagePath,\n        useComment,\n      },\n      {\n        cwd: filePath ? path.dirname(filePath) : null,\n        includedFiles,\n      },\n    );\n  };\n\n  // add md_import core rule\n  md.core.ruler.after(\"normalize\", \"md_import\", includeRule);\n\n  if (resolveImagePath || resolveLinkPath) {\n    md.block.ruler.before(\"table\", \"md_include_start\", includePushRule, {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    });\n    md.block.ruler.before(\"table\", \"md_include_end\", includePopRule, {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    });\n\n    md.renderer.rules.include_start = (tokens, index, _options, env: IncludeEnv): string => {\n      const token = tokens[index];\n      const includedPaths = (env.includedPaths ??= []);\n\n      includedPaths.push(token.info);\n\n      return \"\";\n    };\n\n    md.renderer.rules.include_end = (_tokens, _index, _options, env: IncludeEnv): string => {\n      const includedPaths = env.includedPaths;\n\n      /* istanbul ignore else -- @preserve */\n      if (Array.isArray(includedPaths)) includedPaths.pop();\n\n      // oxlint-disable-next-line no-console\n      else console.error(`[@mdit/plugin-include]: include_end failed, no include_start.`);\n\n      return \"\";\n    };\n\n    if (resolveImagePath) {\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const defaultImageRender = md.renderer.rules.image!;\n\n      md.renderer.rules.image = (tokens, index, options, env: IncludeEnv, self): string => {\n        const token = tokens[index];\n        const path = currentPath(env);\n\n        if (path) resolveRelatedLink(\"src\", token, path, env.includedPaths);\n\n        // pass token to default renderer.\n        return defaultImageRender(tokens, index, options, env, self);\n      };\n    }\n\n    if (resolveLinkPath) {\n      const defaultLinkRender =\n        md.renderer.rules.link_open ??\n        ((tokens, index, options, _env, self): string => self.renderToken(tokens, index, options));\n\n      md.renderer.rules.link_open = (tokens, index, options, env: IncludeEnv, self): string => {\n        const token = tokens[index];\n        const path = currentPath(env);\n\n        if (path) resolveRelatedLink(\"href\", token, path, env.includedPaths);\n\n        // pass token to default renderer.\n        return defaultLinkRender(tokens, index, options, env, self);\n      };\n    }\n  }\n};\n"],"mappings":"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"}