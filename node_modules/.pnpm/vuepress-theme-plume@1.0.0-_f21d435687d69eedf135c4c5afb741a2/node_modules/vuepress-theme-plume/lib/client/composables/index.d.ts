import { App, ComputedRef, InjectionKey, MaybeRef, MaybeRefOrGetter, Ref } from "vue";
import { PageDataRef, PageFrontmatterRef, Router, SiteLocaleDataRef, useRoute, useRouter } from "vuepress/client";
import { BulletinOptions, CopyrightFrontmatter, GitContributor, NavItemWithLink, PresetLocale, ResolvedNavItem, ResolvedSidebarItem, ThemeBaseCollection, ThemeCollectionItem, ThemeData, ThemeDocCollection, ThemeFriendsFrontmatter, ThemeHomeFrontmatter, ThemeLocaleData, ThemeOutline, ThemePageData, ThemePageFrontmatter, ThemePostCollection, ThemePostFrontmatter, ThemePosts, ThemePostsItem, ThemeSidebar, ThemeSidebarItem, TransitionOptions } from "../../shared/index.js";
import { RouteParamValueRaw } from "vue-router";

//#region src/client/composables/aside.d.ts
declare function useAside(): {
  isAsideEnabled: ComputedRef<boolean>;
};
//#endregion
//#region src/client/composables/bulletin.d.ts
declare function useBulletin<T extends Record<string, any> = Record<string, any>>(): ComputedRef<BulletinOptions & T | undefined>;
declare function useBulletinControl<T extends Record<string, any> = Record<string, any>>(): {
  bulletin: ComputedRef<BulletinOptions & T | undefined>;
  enableBulletin: ComputedRef<boolean>;
  showBulletin: Ref<boolean>;
  close: () => void;
};
//#endregion
//#region src/client/composables/collections.d.ts
type CollectionsRef = Ref<Record<string, ThemeCollectionItem[]>>;
type CollectionItemRef<T extends ThemeBaseCollection> = Ref<T | undefined>;
declare const collectionsRef: CollectionsRef;
declare const collectionItemRef: CollectionItemRef<ThemeBaseCollection>;
declare const useCollections: () => CollectionsRef;
declare const useCollection: <T extends ThemeBaseCollection = ThemeDocCollection>() => CollectionItemRef<T>;
declare function forceUpdateCollection(dir?: string | true): void;
declare function setupCollection(): void;
//#endregion
//#region src/client/composables/contributors.d.ts
interface useContributorsResult {
  mode: ComputedRef<'inline' | 'block'>;
  contributors: ComputedRef<GitContributor[]>;
  hasContributors: ComputedRef<boolean>;
}
declare function useContributors(): useContributorsResult;
//#endregion
//#region src/client/composables/copyright.d.ts
interface useCopyrightResult {
  license: ComputedRef<License>;
  author: ComputedRef<Exclude<CopyrightFrontmatter['author'], string>>;
  hasCopyright: ComputedRef<boolean>;
  creation: ComputedRef<CopyrightFrontmatter['creation']>;
  creationText: ComputedRef<string>;
  sourceUrl: ComputedRef<string | undefined>;
}
declare function useCopyright(copyright: ComputedRef<CopyrightFrontmatter>): useCopyrightResult;
interface License {
  name: string;
  url?: string;
  icons?: string[];
}
//#endregion
//#region src/client/composables/css-var.d.ts
/**
 * Get css variable
 * @param prop css variable name
 * @param initialValue
 */
declare function useCssVar(prop: MaybeRefOrGetter<string | null | undefined>, initialValue?: string): ComputedRef<string | null | undefined>;
//#endregion
//#region src/client/composables/dark-mode.d.ts
type DarkModeRef = Ref<boolean>;
declare const darkModeSymbol: InjectionKey<DarkModeRef>;
declare function enableTransitions(): boolean;
declare function setupDarkMode(app: App): void;
/**
 * Inject dark mode global computed
 */
declare function useDarkMode(): DarkModeRef;
//#endregion
//#region src/client/composables/theme-data.d.ts
type ThemeDataRef<T extends ThemeData = ThemeData> = Ref<T>;
type ThemeLocaleDataRef<T extends ThemeData = ThemeData> = ComputedRef<T>;
declare const themeLocaleDataSymbol: InjectionKey<ThemeLocaleDataRef>;
declare const themeData: ThemeDataRef;
declare function useThemeData<T extends ThemeData = ThemeData>(): ThemeDataRef<T>;
declare function useThemeLocaleData<T extends ThemeData = ThemeData>(): ThemeLocaleDataRef<T>;
declare function setupThemeData(app: App): void;
//#endregion
//#region src/client/composables/data.d.ts
type FrontmatterType = 'home' | 'post' | 'friends' | 'page';
type FrontmatterCollectionType = 'post' | 'doc';
type Frontmatter<T extends FrontmatterType = 'page'> = T extends 'home' ? ThemeHomeFrontmatter : T extends 'post' ? ThemePostFrontmatter : T extends 'friends' ? ThemeFriendsFrontmatter : ThemePageFrontmatter;
interface Data<T extends FrontmatterType = 'page', C extends FrontmatterCollectionType = 'doc'> {
  theme: ThemeLocaleDataRef<ThemeLocaleData>;
  page: PageDataRef<ThemePageData>;
  frontmatter: PageFrontmatterRef<Frontmatter<T> & Record<string, unknown>>;
  lang: Ref<string>;
  site: SiteLocaleDataRef;
  isDark: Ref<boolean>;
  collection: CollectionItemRef<C extends 'doc' ? ThemeDocCollection : ThemePostCollection>;
}
declare function useData<T extends FrontmatterType = 'page', C extends FrontmatterCollectionType = 'doc'>(): Data<T, C>;
//#endregion
//#region src/client/composables/edit-link.d.ts
declare function useEditLink(): ComputedRef<null | NavItemWithLink>;
//#endregion
//#region src/client/composables/encrypt-data.d.ts
type EncryptConfig = readonly [boolean, string, string, string[], Record<string, string>];
interface EncryptDataRule {
  key: string;
  match: string;
  rules: string[];
}
interface EncryptData {
  global: boolean;
  separator: string;
  admins: string[];
  matches: string[];
  ruleList: EncryptDataRule[];
}
type EncryptRef = Ref<EncryptData>;
declare const encrypt: EncryptRef;
declare function useEncryptData(): EncryptRef;
//#endregion
//#region src/client/composables/encrypt.d.ts
interface Encrypt {
  hasPageEncrypt: Ref<boolean>;
  isGlobalDecrypted: Ref<boolean>;
  isPageDecrypted: Ref<boolean>;
  hashList: Ref<EncryptDataRule[]>;
}
declare const EncryptSymbol: InjectionKey<Encrypt>;
declare function setupEncrypt(): void;
declare function useEncrypt(): Encrypt;
declare function useEncryptCompare(): {
  compareGlobal: (password: string) => Promise<boolean>;
  comparePage: (password: string) => Promise<boolean>;
};
//#endregion
//#region src/client/composables/flyout.d.ts
interface UseFlyoutOptions {
  el: Ref<HTMLElement | undefined>;
  onFocus?: () => void;
  onBlur?: () => void;
}
declare const focusedElement: Ref<HTMLElement | undefined>;
declare function useFlyout(options: UseFlyoutOptions): Readonly<Ref<boolean>>;
//#endregion
//#region src/client/composables/icons.d.ts
interface IconsRawData {
  co: string[];
  bg: Record<number, string[]>;
  mask: Record<number, string[]>;
}
interface IconsData {
  bg: string[];
  mask: string[];
}
type IconsDataRef = Ref<IconsData>;
declare const useIconsData: () => IconsDataRef;
declare const socialFallbacks: Record<string, string>;
declare function resolveIconsData({
  co,
  bg,
  mask
}: IconsRawData): IconsData;
declare function normalizeIconClassname(icon: string): string;
//#endregion
//#region src/client/composables/internal-link.d.ts
interface InternalLink {
  text: string;
  link: string;
}
declare function useInternalLink(): {
  home: ComputedRef<InternalLink>;
  posts: ComputedRef<InternalLink | undefined>;
  tags: ComputedRef<InternalLink | undefined>;
  archive: ComputedRef<InternalLink | undefined>;
  categories: ComputedRef<InternalLink | undefined>;
};
//#endregion
//#region src/client/composables/langs.d.ts
interface Lang {
  text?: string;
  link: string;
}
interface UseLangOptions {
  removeCurrent?: boolean;
}
interface UseLangResult {
  localeLinks: ComputedRef<Lang[]>;
  currentLang: ComputedRef<Lang>;
}
declare function useLangs({
  removeCurrent
}?: UseLangOptions): UseLangResult;
//#endregion
//#region src/client/composables/latest-updated.d.ts
declare function useLastUpdated(): {
  datetime: Ref<string>;
  isoDatetime: ComputedRef<string | undefined>;
  lastUpdatedText: ComputedRef<string>;
};
//#endregion
//#region src/client/composables/link.d.ts
interface UseLinkResult {
  /**
   * 外部链接
   */
  isExternal: ComputedRef<boolean>;
  /**
   * 外部链接协议
   * 此项不包含 target="_blank" 的情况
   */
  isExternalProtocol: ComputedRef<boolean>;
  link: ComputedRef<string | undefined>;
}
declare function useLink(href: MaybeRefOrGetter<string | undefined>, target?: MaybeRefOrGetter<string | undefined>): UseLinkResult;
//#endregion
//#region src/client/composables/nav.d.ts
declare function useNavbarData(): Ref<ResolvedNavItem[]>;
interface UseNavReturn {
  isScreenOpen: Ref<boolean>;
  openScreen: () => void;
  closeScreen: () => void;
  toggleScreen: () => void;
}
declare function useNav(): UseNavReturn;
//#endregion
//#region src/client/composables/outline.d.ts
interface Header {
  /**
   * The level of the header
   *
   * `1` to `6` for `<h1>` to `<h6>`
   */
  level: number;
  /**
   * The title of the header
   */
  title: string;
  /**
   * The slug of the header
   *
   * Typically the `id` attr of the header anchor
   */
  slug: string;
  /**
   * Link of the header
   *
   * Typically using `#${slug}` as the anchor hash
   */
  link: string;
  /**
   * The children of the header
   */
  children: Header[];
}
type MenuItem = Omit<Header, 'slug' | 'children'> & {
  element: HTMLHeadElement;
  children?: MenuItem[];
  lowLevel?: number;
};
declare const headersSymbol: InjectionKey<Ref<MenuItem[]>>;
declare function setupHeaders(): Ref<MenuItem[]>;
declare function useHeaders(): Ref<MenuItem[]>;
declare function getHeaders(range?: ThemeOutline): MenuItem[];
declare function resolveHeaders(headers: MenuItem[], high: number): MenuItem[];
declare function useActiveAnchor(container: Ref<HTMLElement | null>, marker: Ref<HTMLElement | null>): void;
//#endregion
//#region src/client/composables/page.d.ts
declare function usePostsPageData(): {
  isPosts: ComputedRef<boolean>;
  isPostsLayout: ComputedRef<boolean>;
};
//#endregion
//#region src/client/composables/posts-archives.d.ts
type ShortPostsItem = Pick<ThemePostsItem, 'title' | 'path' | 'createTime'>;
interface ArchiveItem {
  title: string;
  label: string;
  list: ShortPostsItem[];
}
declare function useArchives(): {
  archives: ComputedRef<ArchiveItem[]>;
};
//#endregion
//#region src/client/composables/posts-category.d.ts
interface CategoryItemWithPost {
  type: 'post';
  title: string;
  path: string;
}
interface CategoryItem {
  id: string;
  type: 'category';
  sort: number;
  title: string;
  items: (CategoryItem | CategoryItemWithPost)[];
}
type PostsCategory = (CategoryItem | CategoryItemWithPost)[];
declare function usePostsCategory(): {
  categories: ComputedRef<PostsCategory>;
};
//#endregion
//#region src/client/composables/posts-data.d.ts
type PostsDataRef = Ref<Record<string, ThemePosts>>;
declare const postsData: PostsDataRef;
declare function usePostsData(): PostsDataRef;
declare function useLocalePostList(): ComputedRef<ThemePosts>;
//#endregion
//#region src/client/composables/posts-extract.d.ts
interface PostsExtractLink {
  link?: string;
  text?: string;
  total: number;
}
declare function usePostsExtract(): {
  hasPostsExtract: ComputedRef<boolean>;
  tags: ComputedRef<PostsExtractLink>;
  archives: ComputedRef<PostsExtractLink>;
  categories: ComputedRef<PostsExtractLink>;
};
//#endregion
//#region src/client/composables/posts-post-list.d.ts
interface UsePostListControlResult {
  postList: ComputedRef<ThemePostsItem[]>;
  page: Ref<number>;
  totalPage: ComputedRef<number>;
  pageRange: ComputedRef<{
    value: number | string;
    more?: true;
  }[]>;
  isLastPage: ComputedRef<boolean>;
  isFirstPage: ComputedRef<boolean>;
  isPaginationEnabled: ComputedRef<boolean>;
  changePage: (page: number) => void;
}
declare function usePostListControl(homePage: Ref<boolean>): UsePostListControlResult;
//#endregion
//#region src/client/composables/posts-tags.d.ts
type ShortPostItem = Pick<ThemePostsItem, 'title' | 'path' | 'createTime'>;
interface PostsTagItem {
  name: string;
  count: string | number;
  className: string;
}
interface UseTagsResult {
  tags: ComputedRef<PostsTagItem[]>;
  currentTag: Ref<string>;
  postList: ComputedRef<ShortPostItem[]>;
  handleTagClick: (tag: string) => void;
}
declare function useTags(): UseTagsResult;
//#endregion
//#region src/client/composables/preset-locales.d.ts
interface PresetLocales {
  [locale: string]: PresetLocale;
}
declare const presetLocales: PresetLocales;
declare function getPresetLocaleData(locale: string, name: keyof PresetLocale): string;
//#endregion
//#region src/client/composables/prev-next.d.ts
interface UsePrevNextResult {
  prev: ComputedRef<NavItemWithLink | null>;
  next: ComputedRef<NavItemWithLink | null>;
}
declare function usePrevNext(): UsePrevNextResult;
//#endregion
//#region src/client/composables/route-query.d.ts
type RouteQueryValueRaw = RouteParamValueRaw | string[];
interface ReactiveRouteOptions {
  /**
   * Mode to update the router query, ref is also acceptable
   *
   * @default 'replace'
   */
  mode?: MaybeRef<'replace' | 'push'>;
  /**
   * Route instance, use `useRoute()` if not given
   */
  route?: ReturnType<typeof useRoute>;
  /**
   * Router instance, use `useRouter()` if not given
   */
  router?: ReturnType<typeof useRouter>;
}
interface ReactiveRouteOptionsWithTransform<V, R> extends ReactiveRouteOptions {
  /**
   * Function to transform data before return
   */
  transform?: (val: V) => R;
}
declare function useRouteQuery(name: string): Ref<null | string | string[]>;
declare function useRouteQuery<T extends RouteQueryValueRaw = RouteQueryValueRaw, K = T>(name: string, defaultValue?: MaybeRefOrGetter<T>, options?: ReactiveRouteOptionsWithTransform<T, K>): Ref<K>;
//#endregion
//#region src/client/composables/scroll-behavior.d.ts
declare function enhanceScrollBehavior(router: Router): void;
//#endregion
//#region src/client/composables/scroll-promise.d.ts
interface ScrollPromise {
  wait: () => Promise<void> | null;
  pending: () => void;
  resolve: () => void;
}
declare const useScrollPromise: () => ScrollPromise;
//#endregion
//#region src/client/composables/sidebar-data.d.ts
type SidebarData = Record<string, ThemeSidebar>;
type SidebarDataRef = Ref<SidebarData>;
type AutoDirSidebarRef = Ref<ThemeSidebarItem[] | {
  link: string;
  items: ThemeSidebarItem[];
}>;
type AutoHomeDataRef = Ref<Record<string, string>>;
declare const sidebarData: SidebarDataRef;
declare const autoDirSidebar: AutoDirSidebarRef;
declare function setupSidebar(): void;
declare function useSidebarData(): Ref<ResolvedSidebarItem[]>;
/**
 * Get the `Sidebar` from sidebar option. This method will ensure to get correct
 * sidebar config from `MultiSideBarConfig` with various path combinations such
 * as matching `guide/` and `/guide/`. If no matching config was found, it will
 * return empty array.
 */
declare function getSidebar(routePath: string, routeLocal: string): ResolvedSidebarItem[];
/**
 * Get or generate sidebar group from the given sidebar items.
 */
declare function getSidebarGroups(sidebar: ResolvedSidebarItem[]): ResolvedSidebarItem[];
declare function getSidebarFirstLink(sidebar: ResolvedSidebarItem[]): string;
//#endregion
//#region src/client/composables/sidebar.d.ts
/**
 * Check if the given sidebar item contains any active link.
 */
declare function hasActiveLink(path: string, items: ResolvedSidebarItem | ResolvedSidebarItem[]): boolean;
interface SidebarControl {
  collapsed: Ref<boolean>;
  collapsible: ComputedRef<boolean>;
  isLink: ComputedRef<boolean>;
  isActiveLink: Ref<boolean>;
  hasActiveLink: ComputedRef<boolean>;
  hasChildren: ComputedRef<boolean>;
  toggle: () => void;
}
interface UseSidebarReturn {
  isOpen: Ref<boolean>;
  sidebar: Ref<ResolvedSidebarItem[]>;
  sidebarKey: Ref<string>;
  sidebarGroups: Ref<ResolvedSidebarItem[]>;
  hasSidebar: ComputedRef<boolean>;
  hasAside: ComputedRef<boolean>;
  leftAside: ComputedRef<boolean>;
  isSidebarEnabled: ComputedRef<boolean>;
  open: () => void;
  close: () => void;
  toggle: () => void;
}
declare function useSidebar(): UseSidebarReturn;
/**
 * a11y: cache the element that opened the Sidebar (the menu button) then
 * focus that button again when Menu is closed with Escape key.
 */
declare function useCloseSidebarOnEscape(isOpen: Ref<boolean>, close: () => void): void;
declare function useSidebarControl(item: ComputedRef<ResolvedSidebarItem>): SidebarControl;
//#endregion
//#region src/client/composables/tag-colors.d.ts
type TagColors = Record<string, string>;
type TagColorsRef = Ref<TagColors>;
declare const useTagColors: () => TagColorsRef;
//#endregion
//#region src/client/composables/view-transition.d.ts
type TransitionMode = Exclude<TransitionOptions['appearance'], boolean>;
declare function resolveTransitionKeyframes(x: number, y: number, mode: TransitionMode, isDark: boolean): {
  keyframes: PropertyIndexedKeyframes;
  duration: number;
};
//#endregion
//#region src/client/composables/watermark.d.ts
declare function setupWatermark(): void;
//#endregion
export { AutoDirSidebarRef, AutoHomeDataRef, CategoryItem, CategoryItemWithPost, CollectionItemRef, CollectionsRef, Data, Encrypt, EncryptConfig, EncryptData, EncryptDataRule, EncryptRef, EncryptSymbol, Header, InternalLink, MenuItem, PostsCategory, PostsDataRef, ReactiveRouteOptions, ReactiveRouteOptionsWithTransform, RouteQueryValueRaw, ScrollPromise, ShortPostsItem, SidebarControl, SidebarData, SidebarDataRef, TagColors, TagColorsRef, ThemeDataRef, ThemeLocaleDataRef, UseNavReturn, UseSidebarReturn, autoDirSidebar, collectionItemRef, collectionsRef, darkModeSymbol, enableTransitions, encrypt, enhanceScrollBehavior, focusedElement, forceUpdateCollection, getHeaders, getPresetLocaleData, getSidebar, getSidebarFirstLink, getSidebarGroups, hasActiveLink, headersSymbol, normalizeIconClassname, postsData, presetLocales, resolveHeaders, resolveIconsData, resolveTransitionKeyframes, setupCollection, setupDarkMode, setupEncrypt, setupHeaders, setupSidebar, setupThemeData, setupWatermark, sidebarData, socialFallbacks, themeData, themeLocaleDataSymbol, useActiveAnchor, useArchives, useAside, useBulletin, useBulletinControl, useCloseSidebarOnEscape, useCollection, useCollections, useContributors, useCopyright, useCssVar, useDarkMode, useData, useEditLink, useEncrypt, useEncryptCompare, useEncryptData, useFlyout, useHeaders, useIconsData, useInternalLink, useLangs, useLastUpdated, useLink, useLocalePostList, useNav, useNavbarData, usePostListControl, usePostsCategory, usePostsData, usePostsExtract, usePostsPageData, usePrevNext, useRouteQuery, useScrollPromise, useSidebar, useSidebarControl, useSidebarData, useTagColors, useTags, useThemeData, useThemeLocaleData };