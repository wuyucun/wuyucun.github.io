{"version":3,"file":"index.js","names":[],"sources":["../src/helper/constants.ts","../src/helper/getAttrs.ts","../src/helper/addAttrs.ts","../src/helper/getDelimiterChecker.ts","../src/helper/getMatchingOpeningToken.ts","../src/utils.ts","../src/helper/testRule.ts","../src/rules/types.ts","../src/rules/block.ts","../src/rules/fence.ts","../src/rules/heading.ts","../src/rules/inline.ts","../src/rules/list.ts","../src/rules/softbreak.ts","../src/rules/hr.ts","../src/rules/table.ts","../src/rules/rules.ts","../src/plugin.ts"],"sourcesContent":["/** . */\nexport const CLASS_MARKER = 46;\n/** # */\nexport const ID_MARKER = 35;\n/** space */\nexport const PAIR_SEPARATOR = 32;\n/** = */\nexport const KEY_SEPARATOR = 61;\n/** \" */\nexport const QUOTE_MARKER = 34;\n","import {\n  CLASS_MARKER,\n  ID_MARKER,\n  KEY_SEPARATOR,\n  PAIR_SEPARATOR,\n  QUOTE_MARKER,\n} from \"./constants.js\";\nimport type { Attr } from \"./types.js\";\nimport type { DelimiterRange } from \"../rules/types.js\";\n\nconst isAllowedKeyChar = (charCode: number): boolean =>\n  !(\n    (\n      charCode === 9 /* \\t */ ||\n      charCode === 10 /* \\n */ ||\n      charCode === 12 /* \\f */ ||\n      charCode === 32 /* 空格 */ ||\n      charCode === 47 /* / */ ||\n      charCode === 62 /* > */ ||\n      charCode === 34 /* \" */ ||\n      charCode === 39 /* ' */ ||\n      charCode === 61\n    ) /* = */\n  );\n\nexport const getAttrs = (\n  str: string,\n  range: DelimiterRange,\n  allowed: (string | RegExp)[],\n): Attr[] => {\n  let key = \"\";\n  let value = \"\";\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  const attrs: Attr[] = [];\n\n  // read inside marker\n  // start + left delimiter length to avoid beginning marker\n  // breaks when ending marker is found or end of string\n  for (let index = range[0]; index < range[1]; index++) {\n    const charCode = str.charCodeAt(index);\n\n    // switch to reading value if equal sign\n    if (charCode === KEY_SEPARATOR && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (charCode === CLASS_MARKER && key === \"\") {\n      if (str.charCodeAt(index + 1) === CLASS_MARKER) {\n        key = \"css-module\";\n        index++;\n      } else {\n        key = \"class\";\n      }\n\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (charCode === ID_MARKER && key === \"\") {\n      key = \"id\";\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (charCode === QUOTE_MARKER && value === \"\" && !valueInsideQuotes) {\n      valueInsideQuotes = true;\n      continue;\n    }\n\n    if (charCode === QUOTE_MARKER && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if (charCode === PAIR_SEPARATOR && !valueInsideQuotes) {\n      if (key === \"\") {\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n      }\n\n      attrs.push([key, value]);\n      key = \"\";\n      value = \"\";\n      parsingKey = true;\n\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && !isAllowedKeyChar(charCode)) continue;\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += String.fromCharCode(charCode);\n      continue;\n    }\n\n    value += String.fromCharCode(charCode);\n  }\n\n  // append last key/value pair\n  if (key !== \"\") attrs.push([key, value]);\n\n  return allowed.length > 0\n    ? attrs.filter(([attr]) =>\n        allowed.some((item) => (item instanceof RegExp ? item.test(attr) : item === attr)),\n      )\n    : attrs;\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport { getAttrs } from \"./getAttrs.js\";\nimport type { DelimiterRange } from \"../rules/types.js\";\n\nexport const addAttrs = (\n  token: Token | null,\n  content: string,\n  range: DelimiterRange,\n  allowed: (string | RegExp)[],\n): void => {\n  if (!token) return;\n\n  getAttrs(content, range, allowed).forEach(([key, value]) => {\n    switch (key) {\n      case \"class\": {\n        token.attrJoin(\"class\", value);\n        break;\n      }\n      case \"css-module\": {\n        token.attrJoin(\"css-module\", value);\n        break;\n      }\n      default: {\n        token.attrPush([key, value]);\n      }\n    }\n  });\n};\n","import { CLASS_MARKER, ID_MARKER } from \"./constants.js\";\nimport type { DelimiterConfig } from \"./types.js\";\nimport type { DelimiterChecker } from \"../rules/types.js\";\n\n/**\n * Get a function to check if a string matches the delimiter pattern\n * 获取一个函数来检查字符串是否匹配分隔符模式\n *\n * @param options - Delimiter configuration / 分隔符配置\n * @param where - Position for matching: start, end, or only / 匹配位置：开始、结束或仅匹配\n * @returns A function that checks if content matches the delimiter pattern / 检查内容是否匹配分隔符模式的函数\n */\nexport const getDelimiterChecker = (\n  options: DelimiterConfig,\n  where: \"start\" | \"end\" | \"only\",\n): DelimiterChecker => {\n  if (![\"start\", \"end\", \"only\"].includes(where))\n    throw new Error(`Invalid 'where' parameter: ${where}. Expected 'start', 'end', or 'only'.`);\n\n  // Cache frequently used values\n  const left = options.left;\n  const right = options.right;\n  const leftLength = left.length;\n  const rightLength = right.length;\n  const minContentLength = leftLength + 1 + rightLength;\n\n  return (content) => {\n    // Quick check for minimum length requirements\n    if (typeof content !== \"string\" || content.length < minContentLength) return false;\n\n    let start: number;\n    let end: number;\n\n    if (where === \"start\") {\n      // Check if content starts with left delimiter\n      if (!content.startsWith(left)) return false;\n\n      start = leftLength;\n      end = content.indexOf(right, leftLength + 1);\n\n      if (end === -1) return false;\n\n      // Check if next character is not part of right delimiter\n      const nextCharPos = end + rightLength;\n\n      if (nextCharPos < content.length && right.includes(content.charAt(nextCharPos))) return false;\n    } else if (where === \"end\") {\n      // Check if content ends with right delimiter\n      start = content.lastIndexOf(left);\n\n      if (start === -1) return false;\n\n      end = content.indexOf(right, start + leftLength + 1);\n      start += leftLength;\n\n      if (end === -1 || end + rightLength !== content.length) return false;\n    } else {\n      // Check if content is wrapped by delimiters ('{.a}')\n      if (!content.startsWith(left) || !content.endsWith(right)) return false;\n\n      start = leftLength;\n      end = content.length - rightLength;\n    }\n\n    // Check if content between delimiters is valid\n    const firstCharCode = content.charCodeAt(start);\n    const length = end - start;\n\n    const isValid =\n      firstCharCode === CLASS_MARKER || firstCharCode === ID_MARKER ? length >= 2 : length >= 1;\n\n    if (!isValid) return false;\n\n    return [start, end];\n  };\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nexport const getMatchingOpeningToken = (tokens: Token[], index: number): Token | null => {\n  const token = tokens[index];\n\n  if (token.type === \"softbreak\") return null;\n\n  // non closing blocks, example img\n  if (token.nesting === 0) return token;\n\n  const level = token.level;\n  const type = token.type.replace(\"_close\", \"_open\");\n\n  while (index >= 0) {\n    const currentToken = tokens[index];\n\n    if (currentToken.type === type && currentToken.level === level) return currentToken;\n\n    index--;\n  }\n\n  /* istanbul ignore next -- @preserve */\n  return null;\n};\n","/**\n * Get index item of array. Supports negative index, where -1 is last element in array.\n *\n * 获取数组中的索引项。支持负索引，其中 -1 是数组的最后一个元素。\n *\n * @param arr - Array to get item from / 要获取项的数组\n * @param index - Index of item / 项的索引\n * @returns Array item / 数组项\n */\nexport const getArrayItem = <T>(arr: T[], index: number): T =>\n  index >= 0 ? arr[index] : arr[arr.length + index];\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { AttrRuleSet } from \"../rules/types.js\";\nimport { getArrayItem } from \"../utils.js\";\n\nexport interface TestRuleResult {\n  /** whether rule matches token stream */\n  match: boolean;\n  /** position of token */\n  position: null | number;\n  range: [start: number, end: number] | null;\n}\n\n/**\n * Test if rule matches token stream.\n *\n * @param tokens - token stream\n * @param index - current token index\n * @param rule - rule to test\n *\n * @returns test result\n */\nexport const testRule = (tokens: Token[], index: number, rule: AttrRuleSet): TestRuleResult => {\n  const testResult: TestRuleResult = {\n    match: false,\n    position: null,\n    range: null,\n  };\n  const isShift = rule.shift !== undefined;\n\n  const tokenIndex = isShift ? index + rule.shift : rule.position;\n\n  // we should never shift to negative indexes (rolling around to back of array)\n  if (isShift && tokenIndex < 0) return testResult;\n\n  const token = getArrayItem(tokens, tokenIndex);\n\n  // oxlint-disable-next-line typescript/no-unnecessary-condition\n  if (!token) return testResult;\n\n  const ruleKeys = Object.keys(rule) as (keyof typeof rule)[];\n\n  const ruleKeysLength = ruleKeys.length;\n\n  for (let i = 0; i < ruleKeysLength; i++) {\n    const key = ruleKeys[i];\n\n    if (key === \"shift\" || key === \"position\") continue;\n\n    if (token[key as keyof Token] === undefined) return testResult;\n\n    if (key === \"children\" && Array.isArray(rule.children)) {\n      if (!token.children?.length) return testResult;\n\n      const childTests = rule.children;\n      const children = token.children;\n      let match;\n      let range: [start: number, end: number] | null = null;\n\n      if (childTests.every((childTest) => childTest.position !== undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every((childTest) => {\n          const result = testRule(children, childTest.position, childTest);\n\n          if (!result.match) return false;\n\n          if (result.range) range = result.range;\n\n          return true;\n        });\n\n        if (match) {\n          // get position of child\n          const { position } = childTests[childTests.length - 1];\n\n          testResult.position = position >= 0 ? position : children.length + position;\n\n          // set pos data\n          // oxlint-disable-next-line typescript/no-non-null-assertion\n          testResult.range = range!;\n        }\n      } else {\n        for (let childIndex = 0; childIndex < children.length; childIndex++) {\n          // oxlint-disable-next-line no-loop-func\n          match = childTests.every((childTest) => {\n            const result = testRule(children, childIndex, childTest);\n\n            if (!result.match) return false;\n\n            if (result.range) range = result.range;\n\n            return true;\n          });\n\n          if (match) {\n            testResult.position = childIndex;\n            // set pos data\n            // oxlint-disable-next-line max-depth typescript/no-unnecessary-condition\n            if (range) testResult.range = range;\n\n            // all tests passes. so the check is successful\n            break;\n          }\n        }\n      }\n\n      if (match === false) return testResult;\n\n      continue;\n    }\n\n    // oxlint-disable-next-line typescript/no-unsafe-assignment\n    const ruleDetail = rule[key];\n\n    switch (typeof ruleDetail) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\": {\n        if (token[key] !== ruleDetail) return testResult;\n\n        break;\n      }\n\n      case \"function\": {\n        // oxlint-disable-next-line typescript/no-unsafe-call\n        const result = ruleDetail(token[key]) as boolean | [start: number, end: number];\n\n        if (!result) return testResult;\n\n        if (Array.isArray(result)) testResult.range = result;\n\n        break;\n      }\n\n      // fall through for objects !== arrays of functions\n      default: {\n        throw new Error(\n          `Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string or function.`,\n        );\n      }\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  testResult.match = true;\n\n  return testResult;\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\nimport type { Nesting } from \"markdown-it/lib/token.mjs\";\n\nexport type DelimiterRange = [start: number, end: number];\nexport type TestFunction<Value = unknown> = (value: Value) => boolean;\nexport type DelimiterChecker = (content: string) => DelimiterRange | false;\n\n/**\n * Token 的属性测试函数映射，用于规则匹配\n *\n * Test function mapping for token properties used in rule matching\n */\nexport type TokenPropTest = {\n  [Key in keyof Token]?: Key extends \"nesting\"\n    ? Nesting | TestFunction<Nesting>\n    : Key extends \"attrs\" | \"map\" | \"children\"\n      ? never\n      : Key extends \"content\" | \"info\"\n        ? string | DelimiterChecker\n        : Token[Key] extends (infer T) | null\n          ? T | TestFunction<T>\n          : Token[Key] | TestFunction<Token[Key]>;\n};\n\n/**\n * 基础属性规则集接口，不包含定位属性\n *\n * Base attribute rule set interface without positioning properties\n */\ninterface BaseAttrRuleSet extends Omit<TokenPropTest, \"children\"> {\n  /**\n   * 子规则集合，用于递归匹配\n   *\n   * Child rule sets for recursive matching\n   */\n  children?: AttrRuleSet[] | TestFunction<Token[]>;\n}\n\n/**\n * 使用shift定位的规则集\n *\n * Rule set using shift for positioning\n */\ninterface ShiftAttrRuleSet extends BaseAttrRuleSet {\n  /**\n   * 相对于当前位置的偏移量，用于查找目标 token\n   *\n   * Offset relative to current position to find target token\n   */\n  shift: number;\n\n  /**\n   * 绝对位置，可选\n   *\n   * Optional absolute position\n   */\n  position?: never;\n}\n\n/**\n * 使用position定位的规则集\n *\n * Rule set using position for positioning\n */\ninterface PositionAttrRuleSet extends BaseAttrRuleSet {\n  /**\n   * 绝对位置，用于在 tokens 数组中直接定位目标 token\n   *\n   * Absolute position to locate target token in tokens array\n   */\n  position: number;\n\n  /**\n   * 相对偏移量，可选\n   *\n   * Optional relative offset\n   */\n  shift?: never;\n}\n\n/**\n * 属性规则集，用于定义如何在 tokens 中查找匹配项\n * 必须指定 shift 或 position 中的一个\n *\n * Attribute rule set for defining how to find matches in tokens\n * One of shift or position must be defined\n */\nexport type AttrRuleSet = ShiftAttrRuleSet | PositionAttrRuleSet;\n\nexport interface AttrRule {\n  name: string;\n  tests: AttrRuleSet[];\n  transform: (tokens: Token[], index: number, childIndex: number, range: DelimiterRange) => void;\n}\n\n/**\n * Define an attribute rule helper\n *\n * @param rule - Attribute rule definition / 属性规则定义\n * @returns Attribute rule passed through without modification / 未被修改的属性规则\n *\n * @example\n * ```ts\n * const rule = defineAttrRule({\n *   name: \"example\",\n *   tests: [],\n *   transform(tokens, index, childIndex, range) {\n *     // transform logic\n *   },\n * });\n * ```\n */\nexport const defineAttrRule = (rule: AttrRule): AttrRule => rule;\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker, getMatchingOpeningToken } from \"../helper/index.js\";\n\nexport const getBlockRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * end of {.block}\n   */\n  defineAttrRule({\n    name: \"end of block\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            content: getDelimiterChecker(options, \"end\"),\n            type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Find the closing token by skipping all nested closing tokens\n      let closingTokenIndex = index + 1;\n\n      while (tokens[closingTokenIndex + 1]?.nesting === -1) closingTokenIndex++;\n\n      // Get the corresponding opening token\n      const openingToken = getMatchingOpeningToken(tokens, closingTokenIndex);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove the attribute syntax from content\n      token.content = content.slice(0, hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex);\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker } from \"../helper/index.js\";\n\nexport const getFenceRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * fenced code blocks\n   *\n   * ```python {.cls}\n   * for i in range(10):\n   *     print(i)\n   * ```\n   */\n  defineAttrRule({\n    name: \"code-block\",\n    tests: [\n      {\n        shift: 0,\n        block: true,\n        info: getDelimiterChecker(options, \"end\"),\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      const token = tokens[index];\n      const { info } = token;\n      const hasTrailingSpace = isSpace(info.charCodeAt(attrStartIndex - 1));\n\n      // Apply attributes to the current token\n      addAttrs(token, info, range, options.allowed);\n\n      // Remove the attribute syntax from info\n      token.info = info.slice(0, hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex);\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker, getMatchingOpeningToken } from \"../helper/index.js\";\n\nexport const getHeadingRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * ## end of {#heading}\n   */\n  defineAttrRule({\n    name: \"end of block\",\n    tests: [\n      {\n        shift: -1,\n        type: \"heading_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            content: getDelimiterChecker(options, \"end\"),\n            type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Get the corresponding opening token\n      const openingToken = getMatchingOpeningToken(tokens, index + 1);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove the attribute syntax from content\n      token.content = content.slice(0, hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex);\n    },\n  });\n","import type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker, getMatchingOpeningToken } from \"../helper/index.js\";\n\nexport const getInlineRules = (options: DelimiterConfig): AttrRule[] => [\n  /**\n   * bla `click()`{.c} ![](img.png){.d}\n   *\n   * differs from 'inline attributes' as it does\n   * not have a closing tag (nesting: -1)\n   */\n  defineAttrRule({\n    name: \"inline nesting self-close\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            type: (str) => str === \"image\" || str === \"code_inline\",\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"start\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n      const targetToken = childTokens[childIndex - 1];\n      const attrsEndIndex = options.right.length + range[1];\n\n      // Apply attributes to the target token\n      addAttrs(targetToken, token.content, range, options.allowed);\n\n      if (token.content.length === attrsEndIndex) childTokens.splice(childIndex, 1);\n      else token.content = token.content.slice(attrsEndIndex);\n    },\n  }),\n\n  /**\n   * *emphasis*{.with attrs=1}\n   */\n  defineAttrRule({\n    name: \"inline attributes\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            nesting: -1, // closing inline tag, </em>{.a}\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"start\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const currentToken = childTokens[childIndex];\n      const { content } = currentToken;\n      const attrsEndIndex = options.right.length + range[1];\n\n      // Find the corresponding opening token\n      const openingToken = getMatchingOpeningToken(childTokens, childIndex - 1);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      currentToken.content = content.slice(attrsEndIndex);\n    },\n  }),\n];\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker, getMatchingOpeningToken } from \"../helper/index.js\";\n\nexport const getListRules = (options: DelimiterConfig): AttrRule[] => [\n  /**\n   * - item\n   * {.a}\n   */\n  defineAttrRule({\n    name: \"list softbreak\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -2,\n            type: \"softbreak\",\n          },\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"only\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n\n      let listOpenIndex = index - 2;\n\n      // Find the list opening token\n      while (\n        tokens[listOpenIndex - 1]?.type !== \"ordered_list_open\" &&\n        tokens[listOpenIndex - 1].type !== \"bullet_list_open\"\n      )\n        listOpenIndex--;\n\n      // Apply attributes to the list opening token\n      addAttrs(tokens[listOpenIndex - 1], token.content, range, options.allowed);\n\n      // Remove the attribute tokens from children\n      tokens[index].children = childTokens.slice(0, -2);\n    },\n  }),\n\n  /**\n   * - nested list\n   *   - with double \\n\n   *   {.a} <-- apply to nested ul\n   *\n   * {.b} <-- apply to root <ul>\n   */\n  defineAttrRule({\n    name: \"list double softbreak\",\n    tests: [\n      {\n        // let this token be i = 0 so that we can erase\n        // the <p>{.a}</p> tokens below\n        shift: 0,\n        type: (type) => type === \"bullet_list_close\" || type === \"ordered_list_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: getDelimiterChecker(options, \"only\"),\n        children: (children) => children.length === 1,\n      },\n      {\n        shift: 3,\n        type: \"paragraph_close\",\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index + 2];\n      const openingToken = getMatchingOpeningToken(tokens, index);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, token.content, range, options.allowed);\n\n      // Remove the paragraph tokens containing the attributes\n      tokens.splice(index + 1, 3);\n    },\n  }),\n\n  /**\n   * - end of {.list-item}\n   */\n  defineAttrRule({\n    name: \"list item end\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"end\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const content = token.content;\n      const attrStartIndex = range[0] - options.left.length;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Apply attributes to the list item opening token\n      addAttrs(tokens[index - 2], content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      token.content = content.slice(0, hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex);\n    },\n  }),\n];\n","import type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker, getMatchingOpeningToken } from \"../helper/index.js\";\n\nexport const getSoftBreakRule = (options: DelimiterConfig): AttrRule =>\n  defineAttrRule({\n    /**\n     * something with softbreak\n     * {.cls}\n     */\n\n    name: \"\\n{.a} softbreak then curly in start\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -2,\n            type: \"softbreak\",\n          },\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"only\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n\n      // Find the last closing tag by searching forward\n      let closingTokenIndex = index + 1;\n\n      while (tokens[closingTokenIndex + 1]?.nesting === -1) closingTokenIndex++;\n\n      // Apply attributes to the opening token\n      addAttrs(\n        getMatchingOpeningToken(tokens, closingTokenIndex),\n        token.content,\n        range,\n        options.allowed,\n      );\n\n      // Remove the softbreak and attribute tokens\n      tokens[index].children = childTokens.slice(0, -2);\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule, DelimiterRange } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker } from \"../helper/index.js\";\n\nexport const getHrRule = (options: DelimiterConfig): AttrRule =>\n  defineAttrRule({\n    /**\n     * horizontal rule --- {#id}\n     */\n    name: \"horizontal rule\",\n    tests: [\n      {\n        shift: 0,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 1,\n        type: \"inline\",\n        children: (children) => children.length === 1,\n        content: (content): DelimiterRange | false => {\n          let pos = 0;\n          let charCode;\n          const markerCode = content.charCodeAt(pos++);\n\n          if (\n            markerCode !== 45 /** - */ &&\n            markerCode !== 42 /** * */ &&\n            markerCode !== 95 /** _ */\n          )\n            return false;\n\n          let count = 1;\n\n          while (pos < content.length) {\n            charCode = content.charCodeAt(pos++);\n            if (charCode !== markerCode) break;\n\n            count++;\n          }\n\n          if (count < 3) return false;\n\n          if (!isSpace(content.charCodeAt(pos - 1))) pos--;\n\n          return getDelimiterChecker(options, \"end\")(content);\n        },\n      },\n      {\n        shift: 2,\n        type: \"paragraph_close\",\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index];\n      // Extract attributes from the inline content\n      const inlineToken = tokens[index + 1];\n      const { content } = inlineToken;\n\n      token.type = \"hr\";\n      token.tag = \"hr\";\n      token.nesting = 0;\n\n      // Apply attributes to the hr token\n      addAttrs(token, content, range, options.allowed);\n      token.markup = content;\n\n      // Remove the inline and closing paragraph tokens\n      tokens.splice(index + 1, 2);\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport { defineAttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker, getMatchingOpeningToken } from \"../helper/index.js\";\n\ninterface TokenWithColumnCount extends Token {\n  meta:\n    | {\n        columnCount?: number;\n        [key: string]: unknown;\n      }\n    | undefined;\n}\n\n// oxlint-disable-next-line max-lines-per-function\nexport const getTableRules = (options: DelimiterConfig): AttrRule[] => [\n  defineAttrRule({\n    /**\n     * | h1 |\n     * | -- |\n     * | c1 |\n     *\n     * {.c}\n     */\n    name: \"table\",\n    tests: [\n      {\n        // let this token be i, such that for-loop continues at\n        // next token after tokens.splice\n        shift: 0,\n        type: \"table_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: getDelimiterChecker(options, \"only\"),\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index + 2];\n      const tableOpeningToken = getMatchingOpeningToken(tokens, index);\n\n      // Apply attributes to the table opening token\n      addAttrs(tableOpeningToken, token.content, range, options.allowed);\n\n      // Remove the paragraph tokens containing the attributes\n      tokens.splice(index + 1, 3);\n    },\n  }),\n  /**\n   * Handle table cell attributes: title {.class}\n   * This rule processes attributes within table cell text content\n   */\n  defineAttrRule({\n    name: \"table cell attributes\",\n    tests: [\n      {\n        shift: -1,\n        type: (type) => type === \"td_open\" || type === \"th_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"end\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const cellOpenToken = tokens[index - 1];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Find last attribute syntax in the content\n\n      // Apply attributes to the table cell token\n      addAttrs(cellOpenToken, content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      token.content = content.slice(0, hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex);\n    },\n  }),\n  defineAttrRule({\n    /**\n     * | A | B |\n     * | -- | -- |\n     * | 1 | 2 |\n     *\n     * | C | D |\n     * | -- | -- |\n     *\n     * only `| A | B |` sets the columnCount metadata\n     */\n    name: \"table thead metadata\",\n    tests: [\n      {\n        shift: 0,\n        type: \"tr_close\",\n      },\n      {\n        shift: 1,\n        type: \"thead_close\",\n      },\n      {\n        shift: 2,\n        type: \"tbody_open\",\n      },\n    ],\n\n    transform: (tokens, index): void => {\n      const trOpenToken = getMatchingOpeningToken(tokens, index);\n      const thCloseToken = tokens[index - 1];\n      let columnCount = 0;\n      let currentIndex = index - 1;\n\n      // Find the matching tr_open token and count columns\n      while (currentIndex > 0) {\n        const currentToken = tokens[currentIndex];\n\n        if (currentToken === trOpenToken) {\n          const tHeadOpenToken = tokens[currentIndex - 1] as TokenWithColumnCount;\n\n          tHeadOpenToken.meta = {\n            ...tHeadOpenToken.meta,\n            columnCount,\n          };\n          break;\n        }\n\n        // Count th_close tokens at the same level\n        if (currentToken.level === thCloseToken.level && currentToken.type === thCloseToken.type)\n          columnCount++;\n\n        currentIndex--;\n      }\n\n      // Apply metadata to tbody_open token\n      const tbodyOpenToken = tokens[index + 2] as TokenWithColumnCount;\n\n      tbodyOpenToken.meta = {\n        ...tbodyOpenToken.meta,\n        columnCount,\n      };\n    },\n  }),\n  defineAttrRule({\n    /**\n     * | A | B | C | D |\n     * | -- | -- | -- | -- |\n     * | 1 | 11 | 111 | 1111 {rowspan=3} |\n     * | 2 {colspan=2 rowspan=2} | 22 | 222 | 2222 |\n     * | 3 | 33 | 333 | 3333 |\n     */\n    name: \"table tbody calculate\",\n    tests: [\n      {\n        shift: 0,\n        type: \"tbody_close\",\n        hidden: false,\n      },\n    ],\n    transform: (tokens, index): void => {\n      let tbodyOpenIndex = index - 2;\n\n      while (tbodyOpenIndex >= 0 && tokens[tbodyOpenIndex].type !== \"tbody_open\") tbodyOpenIndex--;\n\n      const columnCount = (tokens[tbodyOpenIndex] as TokenWithColumnCount).meta?.columnCount ?? 0;\n\n      if (columnCount < 2) return;\n\n      const remainingCellRemovedByRowSpan = Array.from({\n        length: columnCount,\n      }).fill(0) as number[];\n      const rangesToRemove: [start: number, end: number][] = [];\n\n      let currentTokenIndex = tbodyOpenIndex + 1;\n\n      while (currentTokenIndex < index) {\n        // The current token should be tr_open\n        const trOpenIndex = currentTokenIndex;\n        // Find tr_close\n        let trCloseIndex = trOpenIndex + 1;\n\n        while (trCloseIndex < index && tokens[trCloseIndex].type !== \"tr_close\") trCloseIndex++;\n\n        // Collect cell info\n        const cells: [openIndex: number, closeIndex: number][] = [];\n\n        let cellSearchIndex = trOpenIndex + 1;\n\n        // if it's not tr_close, then it should be a td_open or th_open\n        while (cellSearchIndex < trCloseIndex) {\n          let closeIndex = cellSearchIndex + 1;\n\n          // find the close token\n          while (\n            closeIndex < trCloseIndex &&\n            tokens[closeIndex].type !== \"td_close\" &&\n            tokens[closeIndex].type !== \"th_close\"\n          )\n            closeIndex++;\n\n          cells.push([cellSearchIndex, closeIndex]);\n          // move to next token\n          cellSearchIndex = closeIndex + 1;\n        }\n\n        let cellIndex = 0;\n        let colIndex = 0;\n\n        while (colIndex < columnCount) {\n          // skip cells removed by rowspan\n          if (remainingCellRemovedByRowSpan[colIndex] > 0) {\n            remainingCellRemovedByRowSpan[colIndex]--;\n            rangesToRemove.push(cells[cellIndex]);\n            cellIndex++;\n            colIndex++;\n            continue;\n          }\n\n          // get rowspan and colspan for current cell\n          const cellOpenToken = tokens[cells[cellIndex][0]];\n          const colspan = Number(cellOpenToken.attrGet(\"colspan\")) || 1;\n          const rowspan = Number(cellOpenToken.attrGet(\"rowspan\")) || 1;\n\n          cellIndex++;\n\n          // Calculate real colspan based on availability\n          let realColspan = 0;\n\n          for (let colSpanIndex = 0; colSpanIndex < colspan; colSpanIndex++) {\n            // colspan should not overflow table columns\n            if (colIndex + colSpanIndex < columnCount) {\n              // the column is not occupied by rowspan\n              if (remainingCellRemovedByRowSpan[colIndex + colSpanIndex] === 0) realColspan++;\n              else break;\n            }\n          }\n\n          if (colspan > 1 && realColspan < colspan)\n            cellOpenToken.attrSet(\"colspan\", String(realColspan));\n\n          // Mark columns as occupied\n          for (let i = 0; i < realColspan; i++) {\n            if (colIndex + i < columnCount)\n              remainingCellRemovedByRowSpan[colIndex + i] = rowspan - 1;\n          }\n\n          // Consume merged cells\n          const cellsToMerge = realColspan - 1;\n\n          if (cellsToMerge > 0) {\n            for (let i = 0; i < cellsToMerge; i++) {\n              rangesToRemove.push(cells[cellIndex]);\n              cellIndex++;\n            }\n          }\n\n          colIndex += realColspan;\n        }\n\n        // Move to next tr\n        currentTokenIndex = trCloseIndex + 1;\n      }\n\n      // Remove tokens in reverse order\n      rangesToRemove.sort((a, b) => b[0] - a[0]);\n      for (const [start, end] of rangesToRemove) tokens.splice(start, end - start + 1);\n    },\n  }),\n];\n","import type { AttrRule } from \"./types.js\";\nimport type { MarkdownItAttrRuleName, MarkdownItAttrsOptions } from \"../options.js\";\nimport { getBlockRule } from \"./block.js\";\nimport { getFenceRule } from \"./fence.js\";\nimport { getHeadingRule } from \"./heading.js\";\nimport { getHrRule } from \"./hr.js\";\nimport { getInlineRules } from \"./inline.js\";\nimport { getListRules } from \"./list.js\";\nimport { getSoftBreakRule } from \"./softbreak.js\";\nimport { getTableRules } from \"./table.js\";\n\nconst AVAILABLE_RULES: MarkdownItAttrRuleName[] = [\n  \"fence\",\n  \"inline\",\n  \"table\",\n  \"list\",\n  \"heading\",\n  \"hr\",\n  \"softbreak\",\n  \"block\",\n];\n\nexport const getRules = (options: Required<MarkdownItAttrsOptions>): AttrRule[] => {\n  const enabledRules =\n    // disable\n    options.rule === false\n      ? []\n      : Array.isArray(options.rule)\n        ? // user specific rules\n          options.rule.filter((item) => AVAILABLE_RULES.includes(item))\n        : AVAILABLE_RULES;\n\n  const rules: AttrRule[] = [];\n\n  if (enabledRules.includes(\"fence\")) rules.push(getFenceRule(options));\n  if (enabledRules.includes(\"inline\")) rules.push(...getInlineRules(options));\n  if (enabledRules.includes(\"table\")) rules.push(...getTableRules(options));\n  if (enabledRules.includes(\"list\")) rules.push(...getListRules(options));\n  if (enabledRules.includes(\"softbreak\")) rules.push(getSoftBreakRule(options));\n  if (enabledRules.includes(\"hr\")) rules.push(getHrRule(options));\n  if (enabledRules.includes(\"block\")) rules.push(getBlockRule(options));\n  // heading rule is fully covered by block rules\n  else if (enabledRules.includes(\"heading\")) rules.push(getHeadingRule(options));\n\n  return rules;\n};\n","/**\n * Forked and modified from https://github.com/arve0/markdown-it-attrs/\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleCore } from \"markdown-it/lib/parser_core.mjs\";\n\nimport { testRule } from \"./helper/index.js\";\nimport type { MarkdownItAttrsOptions } from \"./options.js\";\nimport type { DelimiterRange } from \"./rules/index.js\";\nimport { getRules } from \"./rules/index.js\";\n\nexport const attrs: PluginWithOptions<MarkdownItAttrsOptions> = (\n  md,\n  { left = \"{\", right = \"}\", allowed = [], rule = \"all\" } = {},\n) => {\n  const rules = getRules({\n    left,\n    right,\n    allowed,\n    rule,\n  });\n\n  const attrsRule: RuleCore = (state) => {\n    const tokens = state.tokens;\n\n    for (let index = 0; index < tokens.length; index++) {\n      for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n        const pattern = rules[ruleIndex];\n        // position of child with offset 0\n        let position: null | number = null;\n        let range: DelimiterRange | null = null;\n\n        // oxlint-disable-next-line no-loop-func\n        const match = pattern.tests.every((test) => {\n          const result = testRule(tokens, index, test);\n\n          if (result.position !== null) ({ position } = result);\n          if (result.range) range = result.range;\n\n          return result.match;\n        });\n\n        if (match) {\n          // oxlint-disable-next-line typescript/no-non-null-assertion\n          pattern.transform(tokens, index, position!, range!);\n\n          if (\n            pattern.name === \"inline attributes\" ||\n            pattern.name === \"inline nesting self-close\"\n          ) {\n            // retry, may be several inline attributes\n            ruleIndex--;\n          }\n        }\n      }\n    }\n  };\n\n  md.core.ruler.before(\"linkify\", \"attrs\", attrsRule);\n};\n"],"mappings":"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"}