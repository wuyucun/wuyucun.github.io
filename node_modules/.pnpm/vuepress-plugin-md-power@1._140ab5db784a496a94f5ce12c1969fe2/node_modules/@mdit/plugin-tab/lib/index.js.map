{"version":3,"file":"index.js","names":[],"sources":["../src/plugin.ts"],"sourcesContent":["import { escapeHtml } from \"@mdit/helper\";\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { MarkdownItTabData, MarkdownItTabInfo, MarkdownItTabOptions } from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\nconst TAB_MARKER = \"@tab\";\nconst ACTIVE_TAB_MARKER = `${TAB_MARKER}:active`;\nconst TAB_MARKER_LENGTH = TAB_MARKER.length;\nconst ACTIVE_TAB_MARKER_LENGTH = ACTIVE_TAB_MARKER.length;\n\ninterface TabMeta {\n  index: number;\n  active: boolean;\n  id?: string;\n}\n\nconst checkTabMarker = (\n  state: StateBlock,\n  start: number,\n  max: number,\n): false | { isActive: boolean; pos: number } => {\n  /*\n   * Check out the first character quickly,\n   * this should filter out most of non-uml blocks\n   */\n  if (state.src.charCodeAt(start) !== 64 /* @ */) return false;\n\n  let pos = 1;\n\n  // Check out the rest of the marker string\n  for (; pos < ACTIVE_TAB_MARKER_LENGTH; pos++)\n    if (ACTIVE_TAB_MARKER.charCodeAt(pos) !== state.src.charCodeAt(start + pos)) break;\n\n  const isActive = pos === ACTIVE_TAB_MARKER_LENGTH;\n\n  if (!isActive && pos !== TAB_MARKER_LENGTH) return false;\n\n  const markerEnd = start + pos;\n  const infoStart = state.skipSpaces(markerEnd);\n\n  if (infoStart > markerEnd && infoStart < max) return { isActive, pos: infoStart };\n\n  return false;\n};\n\nconst getTabRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    if (store.state !== name) return false;\n\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n    const indent = state.sCount[startLine];\n\n    const tabMatch = checkTabMarker(state, start, max);\n\n    if (tabMatch === false) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n\n      if (\n        // marker should be indented same as opening one\n        state.sCount[nextLine] === indent &&\n        // match start\n        state.src[nextLineStart] === \"@\" &&\n        // check rest of marker\n        checkTabMarker(state, nextLineStart, state.eMarks[nextLine])\n      ) {\n        // found!\n        autoClosed = true;\n        break;\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error: We are creating a new type called \"tab\"\n    state.parentType = `tab`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = indent;\n\n    const openToken = state.push(`${name}_tab_open`, \"\", 1);\n\n    const infoStart = tabMatch.pos;\n    const infoEnd = state.skipSpacesBack(max, infoStart);\n\n    let pos = infoEnd;\n    let escapePos: number;\n\n    while (pos > infoStart) {\n      /*\n       * Found potential #, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      if (state.src.charCodeAt(pos) === 35 /* # */) {\n        escapePos = pos - 1;\n\n        while (state.src.charCodeAt(escapePos) === 92 /* \\ */) escapePos--;\n\n        // Even number of escapes, potential closing delimiter found\n        if ((pos - escapePos) % 2 === 1) break;\n      }\n\n      pos--;\n    }\n\n    let title;\n    let id = \"\";\n\n    const hasId = pos !== infoStart;\n\n    if (hasId) {\n      id = state.src.slice(state.skipSpaces(pos + 1), infoEnd);\n      title = state.src.slice(infoStart, state.skipSpacesBack(pos, infoStart));\n    } else {\n      title = state.src.slice(infoStart, infoEnd);\n    }\n\n    openToken.block = true;\n    openToken.markup = TAB_MARKER;\n    openToken.info = title;\n    openToken.meta = {\n      active: tabMatch.isActive,\n    };\n    // oxlint-disable-next-line typescript/no-unsafe-member-access\n    if (id) openToken.meta.id = id;\n\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine + (autoClosed ? 0 : 1));\n\n    const closeToken = state.push(`${name}_tab_close`, \"\", -1);\n\n    closeToken.block = true;\n    closeToken.markup = \"\";\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 0 : 1);\n\n    return true;\n  };\n\nconst getTabsRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n    const indent = state.sCount[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    if (state.src.charCodeAt(start) !== 58 /* : */) return false;\n\n    let pos = start + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= max) {\n      if (state.src.charCodeAt(pos) !== 58 /* : */) break;\n\n      pos++;\n    }\n\n    const markerCount = pos - start;\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    pos = state.skipSpaces(pos);\n\n    // check name is matched\n    for (let i = 0; i < name.length; i++) {\n      if (state.src.charCodeAt(pos) !== name.charCodeAt(i)) return false;\n\n      pos++;\n    }\n\n    let hasId = false;\n    let char: number;\n\n    while (pos !== max) {\n      char = state.src.charCodeAt(pos++);\n      if (char === 35 /* # */) {\n        hasId = true;\n        break;\n      }\n      if (!isSpace(char)) return false;\n    }\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n    let idStart = pos;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (nextLineStart < nextLineMax && state.sCount[nextLine] < indent) {\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n      }\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === indent &&\n        // match start\n        state.src.charCodeAt(nextLineStart) === 58 /* : */\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (state.src.charCodeAt(pos) !== 58 /* : */) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (pos - nextLineStart >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n    const oldState = store.state;\n\n    // @ts-expect-error: We are creating a new type called \"${name}_tabs\"\n    state.parentType = `${name}_tabs`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = indent;\n\n    const markup = \":\".repeat(markerCount);\n    let id = \"\";\n\n    if (hasId) {\n      idStart = state.skipSpaces(idStart);\n      const idEnd = state.skipSpacesBack(max, idStart);\n\n      if (idStart < idEnd) id = state.src.slice(idStart, idEnd);\n    }\n\n    const openToken = state.push(`${name}_tabs_open`, \"\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = name;\n    openToken.meta = { id };\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    store.state = name;\n\n    state.md.block.tokenize(state, startLine + 1, nextLine - (autoClosed ? 1 : 0));\n\n    store.state = oldState;\n\n    const closeToken = state.push(`${name}_tabs_close`, \"\", -1);\n\n    closeToken.markup = markup;\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\nconst getTabsDataGetter =\n  (name: string): ((tokens: Token[], index: number) => MarkdownItTabInfo) =>\n  (tokens: Token[], index: number) => {\n    const data: MarkdownItTabData[] = [];\n    let activeIndex = -1;\n    let isTabStart = false;\n    let nestingDepth = 0;\n\n    for (\n      // skip the current tabs_open token\n      let i = index + 1;\n      i < tokens.length;\n      i++\n    ) {\n      const token = tokens[i];\n      const meta = token.meta as TabMeta;\n      const type = token.type;\n\n      if (token.block) {\n        // record the nesting depth of tabs\n        if (type === `${name}_tabs_open`) {\n          nestingDepth++;\n          continue;\n        }\n\n        if (type === `${name}_tabs_close`) {\n          if (nestingDepth === 0) break;\n\n          nestingDepth--;\n          continue;\n        }\n\n        // if we are in a nesting tabs, skip processing\n        if (nestingDepth > 0) continue;\n\n        if (type === `${name}_tab_open`) {\n          isTabStart = true;\n\n          meta.index = data.length;\n          // tab is active\n          if (meta.active) {\n            if (activeIndex === -1) activeIndex = data.length;\n            else meta.active = false;\n          }\n\n          data.push({\n            title: token.info,\n            index: data.length,\n            id: meta.id,\n            isActive: meta.active,\n          });\n\n          continue;\n        }\n\n        if (type === `${name}_tab_close`) continue;\n\n        // hide contents before first tab\n        if (!isTabStart) {\n          tokens[i].type = `${name}_tabs_empty`;\n          tokens[i].hidden = true;\n        }\n      }\n    }\n\n    return {\n      active: activeIndex,\n      data: data,\n    };\n  };\n\nconst tabDataGetter = (tokens: Token[], index: number): MarkdownItTabData => {\n  const token = tokens[index];\n  const meta = token.meta as TabMeta;\n\n  return {\n    title: token.info,\n    index: meta.index,\n    id: meta.id,\n    isActive: meta.active,\n  };\n};\n\nconst store = { state: null };\n\nexport const tab: PluginWithOptions<MarkdownItTabOptions> = (md, options) => {\n  const {\n    name = \"tabs\",\n\n    // oxlint-disable-next-line max-params\n    openRender = (\n      info: MarkdownItTabInfo,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const { active, data } = info;\n      const token = tokens[index];\n\n      token.attrJoin(\"class\", `${name}-tabs-wrapper`);\n      // oxlint-disable-next-line typescript/no-unsafe-member-access\n      if (token.meta.id) token.attrJoin(\"data-id\", token.meta.id as string);\n\n      const tabs = data.map(\n        ({ title, id }, index) =>\n          `<button type=\"button\" class=\"${name}-tab-button${\n            active === index ? \" active\" : \"\"\n          }\" data-tab=\"${index}\"${id ? ` data-id=\"${escapeHtml(id)}\"` : \"\"}${\n            active === index ? \" data-active\" : \"\"\n          }>${escapeHtml(md.renderInline(title))}</button>`,\n      );\n\n      return `\\\n<div${self.renderAttrs(token)}>\n  <div class=\"${name}-tabs-header\">\n    ${tabs.join(\"\\n    \")}\n  </div>\n  <div class=\"${name}-tabs-container\">\n`;\n    },\n\n    closeRender = (): string => `\\\n  </div>\n</div>\n`,\n\n    // oxlint-disable-next-line max-params\n    tabOpenRender = (\n      info: MarkdownItTabData,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n\n      token.attrJoin(\"class\", `${name}-tab-content${info.isActive ? \" active\" : \"\"}`);\n      token.attrSet(\"data-index\", info.index.toString());\n      if (info.id) token.attrSet(\"data-id\", info.id);\n\n      if (info.isActive) token.attrJoin(\"data-active\", \"\");\n\n      return `\\\n<div${self.renderAttrs(tokens[index])}>\n`;\n    },\n\n    tabCloseRender = (): string => `\\\n</div>\n`,\n  } = options ?? {};\n\n  const tabsDataGetter = getTabsDataGetter(name);\n\n  md.block.ruler.before(\"fence\", `${name}_tabs`, getTabsRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.block.ruler.before(\"paragraph\", `${name}_tab`, getTabRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[`${name}_tabs_open`] = (tokens, index, options, env, self): string => {\n    const info = tabsDataGetter(tokens, index);\n\n    return openRender(info, tokens, index, options, env, self);\n  };\n\n  md.renderer.rules[`${name}_tabs_close`] = closeRender;\n\n  md.renderer.rules[`${name}_tab_open`] = (tokens, index, options, env, self): string => {\n    const data = tabDataGetter(tokens, index);\n\n    return tabOpenRender(data, tokens, index, options, env, self);\n  };\n\n  md.renderer.rules[`${name}_tab_close`] = tabCloseRender;\n};\n"],"mappings":"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"}