{"version":3,"file":"index.js","names":[],"sources":["../src/plugins.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItAlertOptions } from \"./options.js\";\n\nconst getAlertRule =\n  // oxlint-disable-next-line max-lines-per-function\n  (types: Set<string>, deep: boolean): RuleBlock =>\n    // oxlint-disable-next-line max-lines-per-function\n    (state, startLine, endLine, silent) => {\n      if (\n        // if it's indented more than 3 spaces, it should be a code block\n        state.sCount[startLine] - state.blkIndent >= 4 ||\n        // check whether it's at first level\n        (state.level !== 0 && !deep)\n      )\n        return false;\n\n      const pos = state.bMarks[startLine] + state.tShift[startLine];\n      const max = state.eMarks[startLine];\n\n      // check the block quote marker\n      if (state.src.charCodeAt(pos) !== 62 /* > */) return false;\n\n      let currentPos = pos + 1;\n\n      let initial = state.sCount[startLine] + 1;\n      let adjustTab = false;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(currentPos) === 32 /* space */) {\n        // ' >   [!tip] '\n        //     ^ -- position start of line here:\n        currentPos++;\n        initial++;\n      } else if (state.src.charCodeAt(currentPos) === 9 /* tab */) {\n        if ((state.bsCount[startLine] + initial) % 4 === 3) {\n          // '  >\\t  [!tip] '\n          //       ^ -- position start of line here (tab has width===1)\n          currentPos++;\n          initial++;\n        } else {\n          // ' >\\t  [!tip] '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      }\n\n      let offset = initial;\n\n      while (currentPos < max) {\n        const ch = state.src.charCodeAt(currentPos);\n\n        if (ch === 9 /** \\t */)\n          offset += 4 - ((offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4);\n        else if (ch === 32 /** space */) offset++;\n        else break;\n\n        currentPos++;\n      }\n\n      // skip blockquote\n      if (offset - initial >= 4) return false;\n\n      // the minimum length of an alert is 4 characters [!x]\n      if (max - currentPos < 4) return false;\n\n      // check opening marker '[!'\n      if (\n        state.src.charCodeAt(currentPos) !== 91 /* [ */ ||\n        state.src.charCodeAt(currentPos + 1) !== 33 /* ! */\n      )\n        return false;\n\n      currentPos += 2;\n\n      let typeName = \"\";\n\n      // find closing bracket ']'\n      while (currentPos < max) {\n        const char = state.src.charAt(currentPos);\n\n        if (char === \"]\") break;\n\n        typeName += char;\n        currentPos++;\n      }\n\n      if (currentPos === max) return false;\n\n      const type = typeName.toLowerCase();\n\n      if (!types.has(type)) return false;\n\n      // skip spaces after ']'\n      currentPos = state.skipSpaces(currentPos + 1);\n\n      // if there are non-space characters after ']', it's not a valid alert\n      if (currentPos < max) return false;\n\n      const oldBMarks: number[] = [];\n      const oldBSCount: number[] = [];\n      const oldSCount: number[] = [];\n      const oldTShift: number[] = [];\n      const oldLineMax = state.lineMax;\n      const oldParentType = state.parentType;\n      const terminatorRules = [\n        state.md.block.ruler.getRules(\"blockquote\"),\n        state.md.block.ruler.getRules(\"alert\"),\n      ].flat();\n\n      // @ts-expect-error: We are creating a new type called \"alert\"\n      state.parentType = \"alert\";\n\n      // Search the end of the block\n      //\n      // Block ends with either:\n      //  1. an empty line outside:\n      //     ```\n      //     > test\n      //\n      //     ```\n      //  2. an empty line inside:\n      //     ```\n      //     >\n      //     test\n      //     ```\n      //  3. another tag:\n      //     ```\n      //     > test\n      //      - - -\n      //     ```\n      let currentLine = startLine;\n      let lastLineEmpty = false;\n\n      for (; currentLine < endLine; currentLine++) {\n        // check if it's outdented, i.e. it's inside list item and indented\n        // less than said list item:\n        //\n        // ```\n        // 1. anything\n        //    > current blockquote\n        // 2. checking this line\n        // ```\n        const isOutdented = state.sCount[currentLine] < state.blkIndent;\n\n        let pos = state.bMarks[currentLine] + state.tShift[currentLine];\n        const max = state.eMarks[currentLine];\n\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        if (pos >= max) break;\n\n        if (state.src.charCodeAt(pos++) === 62 /* > */ && !isOutdented) {\n          // This line is inside the blockquote.\n\n          // set offset past spaces and \">\"\n          let initial = state.sCount[currentLine] + 1;\n          let spaceAfterMarker = false;\n          let adjustTab = false;\n\n          // skip one optional space after '>'\n          if (state.src.charCodeAt(pos) === 32 /* space */) {\n            // ' >   test '\n            //     ^ -- position start of line here:\n            pos++;\n            initial++;\n            spaceAfterMarker = true;\n          } else if (state.src.charCodeAt(pos) === 9 /* \\t */) {\n            spaceAfterMarker = true;\n\n            if ((state.bsCount[currentLine] + initial) % 4 === 3) {\n              // '  >\\t  test '\n              //       ^ -- position start of line here (tab has width===1)\n              pos++;\n              initial++;\n            } else {\n              // ' >\\t  test '\n              //    ^ -- position start of line here + shift bsCount slightly\n              //         to make extra space appear\n              adjustTab = true;\n            }\n          }\n\n          let offset = initial;\n\n          if (!silent) {\n            oldBMarks.push(state.bMarks[currentLine]);\n            state.bMarks[currentLine] = pos;\n          }\n\n          while (pos < max) {\n            const ch = state.src.charCodeAt(pos);\n\n            if (ch === 9 /** \\t */)\n              offset += 4 - ((offset + state.bsCount[currentLine] + (adjustTab ? 1 : 0)) % 4);\n            else if (ch === 32 /** space */) offset++;\n            else break;\n\n            pos++;\n          }\n\n          lastLineEmpty = pos >= max;\n\n          if (!silent) {\n            oldBSCount.push(state.bsCount[currentLine]);\n            state.bsCount[currentLine] = state.sCount[currentLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n            oldSCount.push(state.sCount[currentLine]);\n            state.sCount[currentLine] = offset - initial;\n\n            oldTShift.push(state.tShift[currentLine]);\n            state.tShift[currentLine] = pos - state.bMarks[currentLine];\n          }\n          continue;\n        }\n\n        // Case 2: line is not inside the blockquote, and the last line was empty.\n        // oxlint-disable-next-line typescript/no-unnecessary-condition\n        if (lastLineEmpty) break;\n\n        // Case 3: another tag found.\n        let terminate = false;\n\n        const terminateRuleLength = terminatorRules.length;\n\n        for (let i = 0; i < terminateRuleLength; i++) {\n          const terminatorRule = terminatorRules[i];\n\n          if (terminatorRule(state, currentLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n\n        if (terminate) {\n          // Quirk to enforce \"hard termination mode\" for paragraphs;\n          // normally if you call `tokenize(state, startLine, nextLine)`,\n          // paragraphs will look below nextLine for paragraph continuation,\n          // but if blockquote is terminated by another tag, they shouldn't\n          state.lineMax = currentLine;\n\n          if (state.blkIndent !== 0 && !silent) {\n            // state.blkIndent was non-zero, we now set it to zero,\n            // so we need to re-calculate all offsets to appear as\n            // if indent wasn't changed\n            oldBMarks.push(state.bMarks[currentLine]);\n            oldBSCount.push(state.bsCount[currentLine]);\n            oldSCount.push(state.sCount[currentLine]);\n            oldTShift.push(state.tShift[currentLine]);\n\n            state.sCount[currentLine] -= state.blkIndent;\n          }\n\n          break;\n        }\n\n        if (!silent) {\n          oldBMarks.push(state.bMarks[currentLine]);\n          oldBSCount.push(state.bsCount[currentLine]);\n          oldSCount.push(state.sCount[currentLine]);\n          oldTShift.push(state.tShift[currentLine]);\n\n          // A negative indentation means that this is a paragraph continuation\n          state.sCount[currentLine] = -1;\n        }\n      }\n\n      const restoreState = (): void => {\n        state.lineMax = oldLineMax;\n        state.parentType = oldParentType;\n\n        // Restore original tShift; this might not be necessary since the parser\n        // has already been here, but just to make sure we can do that.\n        for (let i = 0; i < oldTShift.length; i++) {\n          state.bMarks[i + startLine] = oldBMarks[i];\n          state.tShift[i + startLine] = oldTShift[i];\n          state.sCount[i + startLine] = oldSCount[i];\n          state.bsCount[i + startLine] = oldBSCount[i];\n        }\n      };\n\n      // If we didn't find any alert body, so we don't have a valid alert\n      if (startLine + 1 >= currentLine) {\n        // If we are in silent mode, we don't need to restore the state\n        if (!silent) restoreState();\n\n        return false;\n      }\n\n      // from now we know that it's going to be a valid alert,\n      // so no point trying to find the end of it in silent mode\n      if (silent) return true;\n\n      const oldIndent = state.blkIndent;\n\n      state.blkIndent = 0;\n\n      const titleLines: [number, number] = [startLine, startLine + 1];\n      const contentLines: [number, number] = [startLine + 1, 0];\n\n      const openToken = state.push(\"alert_open\", \"div\", 1);\n\n      openToken.markup = type;\n      openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n      openToken.map = contentLines;\n\n      const titleToken = state.push(\"alert_title\", \"\", 0);\n\n      titleToken.attrJoin(\"class\", `markdown-alert-title`);\n      titleToken.markup = type;\n      titleToken.content = typeName;\n      titleToken.map = titleLines;\n\n      state.md.block.tokenize(state, startLine + 1, currentLine);\n\n      const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n      closeToken.markup = type;\n      contentLines[1] = state.line;\n\n      state.blkIndent = oldIndent;\n      restoreState();\n\n      return true;\n    };\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  md.block.ruler.before(\n    \"blockquote\",\n    \"alert\",\n    getAlertRule(new Set(alertNames.map((name) => name.toLowerCase())), deep),\n    {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    },\n  );\n\n  if (openRender) md.renderer.rules.alert_open = openRender;\n\n  if (closeRender) md.renderer.rules.alert_close = closeRender;\n\n  md.renderer.rules.alert_title =\n    titleRender ??\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() + token.content.slice(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],"mappings":"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"}