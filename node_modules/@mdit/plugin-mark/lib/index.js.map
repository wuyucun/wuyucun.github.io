{"version":3,"file":"index.js","names":[],"sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-mark/blob/master/index.mjs\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\nimport type { Delimiter } from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\n/*\n * Insert each marker as a separate text token, and add it to delimiter list\n *\n */\nconst tokenize: RuleInline = (state, silent) => {\n  const start = state.pos;\n  const marker = state.src.charCodeAt(start);\n\n  if (silent || marker !== 61 /* = */) return false;\n\n  const scanned = state.scanDelims(state.pos, true);\n  let length = scanned.length;\n\n  if (length < 2) return false;\n\n  const markerChar = String.fromCharCode(marker);\n\n  if (length % 2) {\n    const token = state.push(\"text\", \"\", 0);\n\n    token.content = markerChar;\n    length--;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const token = state.push(\"text\", \"\", 0);\n\n    token.content = markerChar + markerChar;\n\n    if (scanned.can_open || scanned.can_close) {\n      state.delimiters.push({\n        marker: 0x3d,\n        length: 0, // disable \"rule of 3\" length checks meant for emphasis\n        token: state.tokens.length - 1,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close,\n      });\n    }\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n/*\n * Walk through delimiter list and replace text tokens with tags\n *\n */\nconst postProcess = (state: StateInline, delimiters: Delimiter[]): void => {\n  let token;\n  const loneMarkers = [];\n  const max = delimiters.length;\n\n  for (let i = 0; i < max; i++) {\n    const startDelim = delimiters[i];\n\n    if (startDelim.marker === 0x3d /* = */ && startDelim.end !== -1) {\n      const endDelim = delimiters[startDelim.end];\n\n      token = state.tokens[startDelim.token];\n      token.type = \"mark_open\";\n      token.tag = \"mark\";\n      token.nesting = 1;\n      token.markup = \"==\";\n      token.content = \"\";\n\n      token = state.tokens[endDelim.token];\n      token.type = \"mark_close\";\n      token.tag = \"mark\";\n      token.nesting = -1;\n      token.markup = \"==\";\n      token.content = \"\";\n\n      if (\n        state.tokens[endDelim.token - 1].type === \"text\" &&\n        state.tokens[endDelim.token - 1].content === \"=\"\n      )\n        loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  /*\n   * If a marker sequence has an odd number of characters, itâ€™s splitted\n   * like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n   * start of the sequence.\n   *\n   * So, we have to move all those markers after subsequent s_close tags.\n   *\n   */\n  while (loneMarkers.length > 0) {\n    // oxlint-disable-next-line typescript/no-non-null-assertion\n    const i = loneMarkers.pop()!;\n    let j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === \"mark_close\") j++;\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n};\n\nexport const mark: PluginSimple = (md) => {\n  md.inline.ruler.before(\"emphasis\", \"mark\", tokenize);\n  md.inline.ruler2.before(\"emphasis\", \"mark\", (state) => {\n    postProcess(state, state.delimiters);\n\n    const tokensMeta = state.tokens_meta;\n    const tokensMetaLength = tokensMeta.length;\n\n    if (tokensMetaLength === 0) return true;\n\n    for (let i = 0; i < tokensMetaLength; i++) {\n      const tokenMeta = tokensMeta[i];\n\n      if (tokenMeta?.delimiters.length) postProcess(state, tokenMeta.delimiters);\n    }\n\n    return true;\n  });\n};\n"],"mappings":"AAaA,MAAM,GAAwB,EAAO,IAAW,CAC9C,IAAM,EAAQ,EAAM,IACd,EAAS,EAAM,IAAI,WAAW,EAAM,CAE1C,GAAI,GAAU,IAAW,GAAY,MAAO,GAE5C,IAAM,EAAU,EAAM,WAAW,EAAM,IAAK,GAAK,CAC7C,EAAS,EAAQ,OAErB,GAAI,EAAS,EAAG,MAAO,GAEvB,IAAM,EAAa,OAAO,aAAa,EAAO,CAE9C,GAAI,EAAS,EAAG,CACd,IAAM,EAAQ,EAAM,KAAK,OAAQ,GAAI,EAAE,CAEvC,EAAM,QAAU,EAChB,IAGF,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,GAAK,EAAG,CAClC,IAAM,EAAQ,EAAM,KAAK,OAAQ,GAAI,EAAE,CAEvC,EAAM,QAAU,EAAa,GAEzB,EAAQ,UAAY,EAAQ,YAC9B,EAAM,WAAW,KAAK,CACpB,OAAQ,GACR,OAAQ,EACR,MAAO,EAAM,OAAO,OAAS,EAC7B,IAAK,GACL,KAAM,EAAQ,SACd,MAAO,EAAQ,UAChB,CAAC,CAMN,MAFA,GAAM,KAAO,EAAQ,OAEd,IAOH,GAAe,EAAoB,IAAkC,CACzE,IAAI,EACE,EAAc,EAAE,CAChB,EAAM,EAAW,OAEvB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,IAAK,CAC5B,IAAM,EAAa,EAAW,GAE9B,GAAI,EAAW,SAAW,IAAgB,EAAW,MAAQ,GAAI,CAC/D,IAAM,EAAW,EAAW,EAAW,KAEvC,EAAQ,EAAM,OAAO,EAAW,OAChC,EAAM,KAAO,YACb,EAAM,IAAM,OACZ,EAAM,QAAU,EAChB,EAAM,OAAS,KACf,EAAM,QAAU,GAEhB,EAAQ,EAAM,OAAO,EAAS,OAC9B,EAAM,KAAO,aACb,EAAM,IAAM,OACZ,EAAM,QAAU,GAChB,EAAM,OAAS,KACf,EAAM,QAAU,GAGd,EAAM,OAAO,EAAS,MAAQ,GAAG,OAAS,QAC1C,EAAM,OAAO,EAAS,MAAQ,GAAG,UAAY,KAE7C,EAAY,KAAK,EAAS,MAAQ,EAAE,EAY1C,KAAO,EAAY,OAAS,GAAG,CAE7B,IAAM,EAAI,EAAY,KAAK,CACvB,EAAI,EAAI,EAEZ,KAAO,EAAI,EAAM,OAAO,QAAU,EAAM,OAAO,GAAG,OAAS,cAAc,IAEzE,IAEI,IAAM,IACR,EAAQ,EAAM,OAAO,GACrB,EAAM,OAAO,GAAK,EAAM,OAAO,GAC/B,EAAM,OAAO,GAAK,KAKX,EAAsB,GAAO,CACxC,EAAG,OAAO,MAAM,OAAO,WAAY,OAAQ,EAAS,CACpD,EAAG,OAAO,OAAO,OAAO,WAAY,OAAS,GAAU,CACrD,EAAY,EAAO,EAAM,WAAW,CAEpC,IAAM,EAAa,EAAM,YACnB,EAAmB,EAAW,OAEpC,GAAI,IAAqB,EAAG,MAAO,GAEnC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAkB,IAAK,CACzC,IAAM,EAAY,EAAW,GAEzB,GAAW,WAAW,QAAQ,EAAY,EAAO,EAAU,WAAW,CAG5E,MAAO,IACP"}