{"version":3,"file":"browser.js","names":[],"sources":["../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs","../src/plugin.ts"],"sourcesContent":["// Utilities\n//\n\nimport * as mdurl from 'mdurl'\nimport * as ucmicro from 'uc.micro'\nimport { decodeHTML } from 'entities'\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\n\nfunction isString (obj) { return _class(obj) === '[object String]' }\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction has (object, key) {\n  return _hasOwnProperty.call(object, key)\n}\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object')\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt (src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))\n}\n\nfunction isValidEntityCode (c) {\n  /* eslint no-bitwise:0 */\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false }\n  if (c === 0x0B) { return false }\n  if (c >= 0x0E && c <= 0x1F) { return false }\n  if (c >= 0x7F && c <= 0x9F) { return false }\n  // out of range\n  if (c > 0x10FFFF) { return false }\n  return true\n}\n\nfunction fromCodePoint (c) {\n  /* eslint no-bitwise:0 */\n  if (c > 0xffff) {\n    c -= 0x10000\n    const surrogate1 = 0xd800 + (c >> 10)\n    const surrogate2 = 0xdc00 + (c & 0x3ff)\n\n    return String.fromCharCode(surrogate1, surrogate2)\n  }\n  return String.fromCharCode(c)\n}\n\nconst UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g\nconst ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi\nconst UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')\n\nconst DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i\n\nfunction replaceEntityPattern (match, name) {\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    const code = name[1].toLowerCase() === 'x'\n      ? parseInt(name.slice(2), 16)\n      : parseInt(name.slice(1), 10)\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code)\n    }\n\n    return match\n  }\n\n  const decoded = decodeHTML(match)\n  if (decoded !== match) {\n    return decoded\n  }\n\n  return match\n}\n\n/* function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n} */\n\nfunction unescapeMd (str) {\n  if (str.indexOf('\\\\') < 0) { return str }\n  return str.replace(UNESCAPE_MD_RE, '$1')\n}\n\nfunction unescapeAll (str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped }\n    return replaceEntityPattern(match, entity)\n  })\n}\n\nconst HTML_ESCAPE_TEST_RE = /[&<>\"]/\nconst HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g\nconst HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n}\n\nfunction replaceUnsafeChar (ch) {\n  return HTML_REPLACEMENTS[ch]\n}\n\nfunction escapeHtml (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)\n  }\n  return str\n}\n\nconst REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&')\n}\n\nfunction isSpace (code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true\n  }\n  return false\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace (code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true\n  }\n  return false\n}\n\n/* eslint-disable max-len */\n\n// Currently without astral characters support.\nfunction isPunctChar (ch) {\n  return ucmicro.P.test(ch) || ucmicro.S.test(ch)\n}\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct (ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference (str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ')\n\n  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('ẞ'.toLowerCase() === 'Ṿ') {\n    str = str.replace(/ẞ/g, 'ß')\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change ϑ (it's already lowercase),\n  // and .toUpperCase() doesn't change ϴ (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase()\n}\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nconst lib = { mdurl, ucmicro }\n\nexport {\n  lib,\n  assign,\n  isString,\n  has,\n  unescapeMd,\n  unescapeAll,\n  isValidEntityCode,\n  fromCodePoint,\n  escapeHtml,\n  arrayReplaceAt,\n  isSpace,\n  isWhiteSpace,\n  isMdAsciiPunct,\n  isPunctChar,\n  escapeRE,\n  normalizeReference\n}\n","/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\nconst BLOCK_MARKER = String.raw`\\[`;\nconst INLINE_MARKER = String.raw`\\(`;\n\n/*\n * Count preceding backslashes from a position\n */\nconst countPrecedingBackslashes = (src: string, pos: number, minPos = 0): number => {\n  let count = 0;\n  let checkPos = pos - 1;\n\n  while (checkPos >= minPos && src.charCodeAt(checkPos) === 92 /* \\ */) {\n    count++;\n    checkPos--;\n  }\n\n  return count;\n};\n\n/*\n * Test if potential opening or closing delimiter for dollar syntax\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDollarDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevCharCode = state.src.charCodeAt(pos - 1);\n  const nextCharCode = state.src.charCodeAt(pos + 1);\n\n  return {\n    canOpen: allowInlineWithSpace || !isSpace(nextCharCode),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isn't followed by a number\n     */\n    canClose:\n      !((nextCharCode >= 48 /* 0 */ && nextCharCode <= 57) /* 9 */) &&\n      (allowInlineWithSpace || !isSpace(prevCharCode)),\n  };\n};\n\n/*\n * Parse inline math with dollar signs: $...$\n */\nconst getDollarInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    if (state.src[state.pos] !== \"$\") return false;\n\n    let delimState = isValidDollarDelim(state, state.pos, allowInlineWithSpace);\n\n    if (!delimState.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos++;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    let match = start;\n    let pos: number;\n    const max = state.src.lastIndexOf(\"$\");\n\n    if (max === -1) return false;\n\n    while ((match = state.src.indexOf(\"$\", match)) <= max) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src.charCodeAt(pos) === 92 /* \\ */) pos--;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match++;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    delimState = isValidDollarDelim(state, match, allowInlineWithSpace);\n\n    if (!delimState.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      const token = state.push(\"math_inline\", \"math\", 0);\n\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\n/*\n * Parse inline math with bracket syntax: \\(...\\)\n */\nconst getBracketInlineTex = (): RuleInline => (state, silent) => {\n  const start = state.pos;\n\n  // Check for opening \\(\n  if (state.src.charCodeAt(start) !== 92 /* \\ */ || state.src.charCodeAt(start + 1) !== 40 /* ( */)\n    return false;\n\n  // Look for closing \\)\n  let pos = start + 2;\n  let found = false;\n  const srcLength = state.src.length;\n\n  while (pos < srcLength - 1) {\n    if (state.src.charCodeAt(pos) === 92 /* \\ */ && state.src.charCodeAt(pos + 1) === 41 /* ) */) {\n      // Check if the opening \\( was escaped\n      const openingBackslashes = countPrecedingBackslashes(state.src, start);\n\n      // If opening \\( is escaped (odd number of preceding backslashes), don't parse\n      if (openingBackslashes % 2 === 1) return false;\n\n      // Check if the closing \\) is escaped\n      const closingBackslashes = countPrecedingBackslashes(state.src, pos, start + 2);\n\n      // If closing \\) is not escaped (even number of preceding backslashes), we found it\n      if (closingBackslashes % 2 === 0) {\n        found = true;\n        break;\n      }\n    }\n    pos++;\n  }\n\n  if (!found) return false;\n\n  if (!silent) {\n    const token = state.push(\"math_inline\", \"math\", 0);\n\n    token.markup = INLINE_MARKER;\n    token.content = state.src.slice(start + 2, pos);\n  }\n\n  state.pos = pos + 2;\n\n  return true;\n};\n\n/*\n * Parse block math with dollar signs: $$...$$\n */\nconst dollarBlockTex: RuleBlock = (state, startLine, endLine, silent) => {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  let end = state.eMarks[startLine];\n\n  if (start + 2 > end) return false;\n\n  if (state.src.charCodeAt(start) !== 36 /* $ */ || state.src.charCodeAt(start + 1) !== 36 /* $ */)\n    return false;\n\n  if (silent) return true;\n\n  let contentEnd = state.skipSpacesBack(end, start);\n  let pos = start + 2;\n  let firstLine: string;\n  let found = false;\n\n  if (\n    contentEnd - pos >= 2 &&\n    state.src.charCodeAt(contentEnd - 1) === 36 /* $ */ &&\n    state.src.charCodeAt(contentEnd - 2) === 36 /* $ */\n  ) {\n    // Single line expression\n    firstLine = state.src.slice(pos, contentEnd - 2);\n    found = true;\n  } else {\n    firstLine = state.src.slice(pos, end);\n  }\n\n  let current = startLine;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= endLine) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    end = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < end && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    contentEnd = state.skipSpacesBack(end, pos);\n\n    if (\n      contentEnd - pos >= 2 &&\n      state.src.charCodeAt(contentEnd - 1) === 36 /* $ */ &&\n      state.src.charCodeAt(contentEnd - 2) === 36 /* $ */\n    ) {\n      lastLine = state.src.slice(pos, contentEnd - 2);\n      found = true;\n    }\n  }\n\n  state.line = found ? current + 1 : current;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(startLine + 1, current, state.tShift[startLine], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [startLine, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\n/*\n * Parse block math with bracket syntax: \\[...\\]\n */\nconst getBracketBlockTex = (): RuleBlock => (state, startLine, endLine, silent) => {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  let end = state.eMarks[startLine];\n\n  if (start + 2 > end) return false;\n\n  if (state.src.charCodeAt(start) !== 92 /* \\ */ || state.src.charCodeAt(start + 1) !== 91 /* [ */)\n    return false;\n\n  if (silent) return true;\n\n  let contentEnd = state.skipSpacesBack(end, start);\n  let pos = start + 2;\n  let firstLine: string;\n  let found = false;\n\n  if (\n    contentEnd - pos >= 2 &&\n    state.src.charCodeAt(contentEnd - 1) === 93 /* ] */ &&\n    state.src.charCodeAt(contentEnd - 2) === 92 /* \\ */\n  ) {\n    // Single line expression\n    firstLine = state.src.slice(pos, contentEnd - 2);\n    found = true;\n  } else {\n    firstLine = state.src.slice(pos, end);\n  }\n\n  let current = startLine;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= endLine) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    end = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < end && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    contentEnd = state.skipSpacesBack(end, pos);\n\n    if (\n      contentEnd - pos >= 2 &&\n      state.src.charCodeAt(contentEnd - 1) === 93 /* ] */ &&\n      state.src.charCodeAt(contentEnd - 2) === 92 /* \\ */\n    ) {\n      lastLine = state.src.slice(pos, contentEnd - 2).trimEnd();\n      found = true;\n    }\n  }\n\n  if (!found) return false;\n\n  state.line = current + 1;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(startLine + 1, current, state.tShift[startLine], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [startLine, state.line];\n  token.markup = BLOCK_MARKER;\n\n  return true;\n};\n\nconst ruleOptions = {\n  alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  if (typeof options?.render !== \"function\")\n    throw new TypeError('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  const {\n    allowInlineWithSpace = false,\n    mathFence = false,\n    delimiters = \"dollars\",\n    render,\n  } = options;\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n\n      if (token.info.trim() === \"math\") return render(token.content, true, env);\n\n      // oxlint-disable-next-line typescript/no-non-null-assertion\n      return fence!(tokens, index, options, env, self);\n    };\n  }\n\n  // Register inline and block rules based on delimiters option\n  if (delimiters === \"dollars\" || delimiters === \"all\") {\n    md.inline.ruler.after(\"escape\", \"math_inline_dollar\", getDollarInlineTex(allowInlineWithSpace));\n    md.block.ruler.after(\"blockquote\", \"math_block_dollar\", dollarBlockTex, ruleOptions);\n  }\n\n  if (delimiters === \"brackets\" || delimiters === \"all\") {\n    md.inline.ruler.before(\"escape\", \"math_inline_bracket\", getBracketInlineTex());\n    md.block.ruler.after(\"blockquote\", \"math_block_bracket\", getBracketBlockTex(), ruleOptions);\n  }\n\n  md.renderer.rules.math_inline = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules.math_block = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"x_google_ignoreList":[0],"mappings":"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"}