{"version":3,"file":"browser.js","names":["dedent"],"sources":["../../helper/lib/index.js","../src/options.ts","../src/plugin.ts"],"sourcesContent":["const e=e=>{let t=e.split(`\n`),n=t.reduce((e,t)=>{for(let n=0;n<t.length;n++)if(t[n]!==` `&&t[n]!==`\t`)return Math.min(n,e);return e},1/0);return n<1/0?t.map(e=>e.slice(n)).join(`\n`):e},t=/[-/\\\\^$*+?.()|[\\]{}]/g,n=String.raw`\\$&`,r=e=>e.replaceAll(`&`,`&amp;`).replaceAll(`<`,`&lt;`).replaceAll(`>`,`&gt;`).replaceAll(`\"`,`&quot;`).replaceAll(`'`,`&#39;`),i=e=>e.replaceAll(t,n),a=/\\r\\n?|\\n/g,o=/\\\\([ \\\\!\"#$%&'()*+,./:;<=>?@[\\]^_`{|}~-])/gu;export{a as NEWLINE_RE,o as UNESCAPE_RE,e as dedent,r as escapeHtml,i as escapeRegExp};\n//# sourceMappingURL=index.js.map","import type { RenderRule } from \"markdown-it/lib/renderer.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nexport interface MarkdownItUMLOptions {\n  /**\n   * UML name\n   *\n   * UML 名称\n   */\n  name: string;\n\n  /**\n   * Opening marker\n   *\n   * 开始标记\n   */\n  open: string;\n\n  /**\n   *  Closing marker\n   *\n   * 结束标记\n   */\n  close: string;\n\n  /**\n   * Render function\n   *\n   * 渲染函数\n   */\n  render: RenderRule;\n}\n\nexport const defaultRender = (tokens: Token[], index: number): string => {\n  const token = tokens[index];\n\n  return `<div class=\"${token.type}\" title=\"${token.info}\">${token.content}</div>`;\n};\n","import { dedent } from \"@mdit/helper\";\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItUMLOptions } from \"./options.js\";\nimport { defaultRender } from \"./options.js\";\n\nexport const uml: PluginWithOptions<MarkdownItUMLOptions> = (md, options) => {\n  const { name = \"uml\", open = \"start\", close = \"end\", render = defaultRender } = options ?? {};\n\n  const OPEN_MARKER = `@${open}`;\n  const CLOSE_MARKER = `@${close}`;\n\n  const umlRule: RuleBlock = (state, startLine, endLine, silent) => {\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    /*\n     * Check out the first character quickly,\n     * this should filter out most of non-uml blocks\n     */\n    if (state.src.charCodeAt(start) !== 64 /* @ */) return false;\n\n    let index;\n\n    // Check out the rest of the marker string\n    for (index = 0; index < OPEN_MARKER.length; ++index)\n      if (OPEN_MARKER[index] !== state.src[start + index]) return false;\n\n    const markup = state.src.slice(start, start + index);\n    const params = state.src.slice(start + index, max);\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let autoClosed = false;\n    let nextLine = startLine;\n\n    // Search for the end of the block\n    while (\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine\n    ) {\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - @umlstart\n        //  test\n        break;\n      }\n\n      if (\n        // didn’t find the closing fence\n        state.src.charCodeAt(start) === 64 /* @ */ &&\n        // closing fence should not be indented with respect of opening fence\n        state.sCount[nextLine] <= state.sCount[startLine]\n      ) {\n        let closeMarkerMatched = true;\n\n        for (index = 0; index < CLOSE_MARKER.length; ++index) {\n          if (CLOSE_MARKER[index] !== state.src[start + index]) {\n            closeMarkerMatched = false;\n            break;\n          }\n        }\n\n        if (\n          closeMarkerMatched &&\n          // make sure tail has spaces only\n          state.skipSpaces(start + index) >= max\n        ) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n\n      nextLine++;\n    }\n\n    const contents = state.src\n      .split(\"\\n\")\n      .slice(startLine + 1, nextLine)\n      .join(\"\\n\");\n\n    const umlToken = state.push(name, \"uml\", 0);\n\n    umlToken.block = true;\n    umlToken.info = params;\n    umlToken.content = dedent(contents);\n    umlToken.map = [startLine, nextLine];\n    umlToken.markup = markup;\n\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", name, umlRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[name] = render;\n};\n"],"mappings":"AAAA,MAAM,EAAE,GAAG,CAAC,IAAI,EAAE,EAAE,MAAM;EACxB,CAAC,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,IAAI,EAAE,EAAE,EAAE,EAAE,OAAO,IAAI,GAAG,EAAE,KAAK,KAAK,EAAE,KAAK,IAAI,OAAO,KAAK,IAAI,EAAE,EAAE,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,MAAM,EAAE,CAAC,CAAC,KAAK;EACpJ,CAAC,GAA+B,OAAO,GAAG,MAF5C,MCiCa,GAAiB,EAAiB,IAA0B,CACvE,IAAM,EAAQ,EAAO,GAErB,MAAO,eAAe,EAAM,KAAK,WAAW,EAAM,KAAK,IAAI,EAAM,QAAQ,SC7B9D,GAAgD,EAAI,IAAY,CAC3E,GAAM,CAAE,OAAO,MAAO,OAAO,QAAS,QAAQ,MAAO,SAAS,GAAkB,GAAW,EAAE,CAEvF,EAAc,IAAI,IAClB,EAAe,IAAI,IA0FzB,EAAG,MAAM,MAAM,OAAO,QAAS,GAxFH,EAAO,EAAW,EAAS,IAAW,CAChE,IAAI,EAAQ,EAAM,OAAO,GAAa,EAAM,OAAO,GAC/C,EAAM,EAAM,OAAO,GAMvB,GAAI,EAAM,IAAI,WAAW,EAAM,GAAK,GAAY,MAAO,GAEvD,IAAI,EAGJ,IAAK,EAAQ,EAAG,EAAQ,EAAY,OAAQ,EAAE,EAC5C,GAAI,EAAY,KAAW,EAAM,IAAI,EAAQ,GAAQ,MAAO,GAE9D,IAAM,EAAS,EAAM,IAAI,MAAM,EAAO,EAAQ,EAAM,CAC9C,EAAS,EAAM,IAAI,MAAM,EAAQ,EAAO,EAAI,CAGlD,GAAI,EAAQ,MAAO,GAEnB,IAAI,EAAa,GACb,EAAW,EAGf,KAGE,EAAW,IAEX,EAAQ,EAAM,OAAO,GAAY,EAAM,OAAO,GAC9C,EAAM,EAAM,OAAO,GAEf,IAAQ,GAAO,EAAM,OAAO,GAAY,EAAM,aAJlD,CAWA,GAEE,EAAM,IAAI,WAAW,EAAM,GAAK,IAEhC,EAAM,OAAO,IAAa,EAAM,OAAO,GACvC,CACA,IAAI,EAAqB,GAEzB,IAAK,EAAQ,EAAG,EAAQ,EAAa,OAAQ,EAAE,EAC7C,GAAI,EAAa,KAAW,EAAM,IAAI,EAAQ,GAAQ,CACpD,EAAqB,GACrB,MAIJ,GACE,GAEA,EAAM,WAAW,EAAQ,EAAM,EAAI,EACnC,CAEA,EAAa,GACb,OAIJ,IAGF,IAAM,EAAW,EAAM,IACpB,MAAM;EAAK,CACX,MAAM,EAAY,EAAG,EAAS,CAC9B,KAAK;EAAK,CAEP,EAAW,EAAM,KAAK,EAAM,MAAO,EAAE,CAU3C,MARA,GAAS,MAAQ,GACjB,EAAS,KAAO,EAChB,EAAS,QAAUA,EAAO,EAAS,CACnC,EAAS,IAAM,CAAC,EAAW,EAAS,CACpC,EAAS,OAAS,EAElB,EAAM,KAAO,GAAY,EAAa,EAAI,GAEnC,IAGqC,CAC5C,IAAK,CAAC,YAAa,YAAa,aAAc,OAAO,CACtD,CAAC,CAEF,EAAG,SAAS,MAAM,GAAQ"}